/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */

/*                             */

/*                            */

/*                          */

/*                         */

/*                        */

/*                       */

/*                      */

/*                     */

/*                    */

/*                   */

/*                 */

/*                */

/*               */

/*              */

/*             */

/*            */

/*          */

/*    */

/*   */

/*  */

/* #__PURE__ */

/* */

/* , ...args */

/* , end */

/* , endPosition = @length */

/* , fillString = ' ' */

/* , fromIndex */

/* , fromIndex = 0 */

/* , fromIndex = @[*-1] */

/* , initialValue */

/* , littleEndian */

/* , mapfn = undefined, thisArg = undefined */

/* , mapfn, thisArg */

/* , newTarget */

/* , offset */

/* , position = 0 */

/* , receiver */

/* , start = 0, end = @length */

/* , start, end */

/* , that = undefined */

/* , thisArg */

/* = 0 */

/* = 0, end = @length */

/* Z+1 */

/* empty */

/* eslint-disable max-len */

/* eslint-disable no-new */

/* eslint-disable no-proto */

/* eslint-disable no-unused-expressions */

/* eslint-disable react-internal/no-production-logging */

/* eslint-disable react-internal/prod-error-codes */

/* falls through */

/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

/* global reportError */

/* globals MSApp */

/* harmony default export */

/* module decorator */

/* n */

/* noop */

/* o */

/* webpack/runtime/compat get default export */

/*#__PURE__*/

/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */

/**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */

/**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */

/**
   * @internal
   * @type {ReactComponent}
   */

/**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */

/**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */

/**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */

/**
   * Returns whether
   */

/**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */

/**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */

/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */

/**
   * Warns if there is a duplicate or missing key
   */

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */

/**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */

/**
 * @return {?object} A SyntheticCompositionEvent.
 */

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */

/**
 * A list of event names to a configurable list of vendor prefixes.
 */

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */

/**
 * Base class helpers for the updating state of a component.
 */

/**
 * Bootstrap if a DOM exists.
 */

/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

/**
 * Convenience component with default shallow equality check for sCU.
 */

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */

/**
 * Does our fallback mode think that this event is the end of composition?
 */

/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

/**
 * Event names that have already been detected and prefixed (if applicable).
 */

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */

/**
 * For IE shims
 */

/**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */

/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */

/**
 * Get document associated with the event target.
 */

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */

/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */

/**
 * Keeps track of the current dispatcher.
 */

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */

/**
 * Operations for dealing with CSS properties.
 */

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */

/**
 * SECTION: handle `click` event
 */

/**
 * SECTION: handle `input` event
 */

/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */

/**
 * This is the abstract API for an update queue.
 */

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */

/**
 * Translate native top level events into event types.
 */

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

/**
 * Validation function for `value` and `defaultValue`.
 */

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */

/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/** @noinline */

/************************************************************************/

/******/

/***/

//

//    always know when it is a fiber.

//    compatible.

//    is faster.

//    more difficult to predict when they get optimized and they are almost

//    never inlined properly in static compilers.

//    to optimize in a non-JIT environment.

//   --alternate--> previous live fiber

//   --sibling--> deleted fiber

//   1. The checked React property when present

//   1. The value React property when present

//   2. The defaultChecked React property when present

//   2. The defaultValue React property when present

//   3. An empty string

//   3. Otherwise, false

//   React.forwardRef((props, ref) => {...});

//   React.memo((props) => {...});

//   captures = result.slice(1).map(maybeToString)

//   live fiber

//  1. The value React property

//  2. The defaultValue React property

//  3. Otherwise there should be no change

//  `select` elements automatically pick the first item #13222

// "Member not found" in strict mode, and in Firefox which does not

// "Pause on exceptions" behavior. Because React wraps all user-provided

// "Static" flags share the lifetime of the fiber/hook they belong to,

// "consumed" by the delegate iterator. If context.method was

// "retries" — a special update that attempts to flip a Suspense boundary

// "return", allow the original .return call to continue in the

// "stack" as the parent. Then append children as we go in beginWork

// #match works fine because it just return the exec results, even if it has

// #replace needs built-in support for named groups.

// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global

// $FlowFixMe

// $FlowFixMe - Should be inferred as not undefined.

// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above

// $FlowFixMe Flow doesn't know about toStringTag

// $FlowFixMe Flow doesn't support type casting in combination with the -= operator

// $FlowFixMe Flow gets confused by a WeakSet feature check below.

// $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key

// $FlowFixMe Flow incorrectly thinks existing element's key can be a number

// $FlowFixMe Flow thinks console is immutable.

// $FlowFixMe It does accept undefined.

// $FlowFixMe The Flow type is opaque but there's no way to actually create it.

// $FlowFixMe This is okay but Flow doesn't know it.

// $FlowFixMe This should probably use `delete container._reactRootContainer`

// $FlowFixMe number or string is fine here

// $FlowFixMe only called in DEV, so void return is not possible.

// $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

// $FlowFixMe: Flow complains about not setting a value, which is intentional here

// $FlowFixMe: Flow doesn't like mixed types

// $FlowFixMe: Ignore Flow complaining about needing a value

// $FlowFixMe: Only Element or Document can be parent nodes.

// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors

// $FlowIssue Flow incorrectly thinks Map has no prototype

// $FlowIssue Flow incorrectly thinks Set has no prototype

// $FlowIssue `createElement` should be updated for Web Components

// $FlowIssue symbol is perfectly valid here

// (Even though this is a DOM fork of the Scheduler, you could get here

// (For instance: TinyMCE editor used in a list component that supports pasting to add more,

// (Rendering will throw with a helpful message and as soon as the type is

// (There's no appropriate action type for DevTools overrides.)

// (We don't do this in legacy mode, because in legacy mode we don't re-use

// (and would be incorrectly rendered on the client).

// (eg DOM renderer may schedule auto-focus for inputs and form controls).

// (eg DOM renderer supports auto-focus for certain elements).

// (inside this function), since by suspending at the end of the render

// (needed for certain tests that spyOn input values and Safari)

// (since profiling and timeline are controlled by different feature flags).

// *after* passive effects fire to avoid freeing a cache pool that may

// - BeforeInputEventPlugin

// - ChangeEventPlugin

// - EnterLeaveEventPlugin

// - SelectEventPlugin

// - a bug where the `select` does not scroll to the correct option because singular

// - a bug where the `select` set the first item as selected despite the `size` attribute #14239

// -------------------

// -----------------------------------------------------------------------------

// -progress queue, we need to clone the updates. We usually clone during

// ...)) which otherwise throws a "_processChildContext is not a function"

// .constructor.prototype properties for functions that return Generator

// .throw, and .return (see defineIteratorMethods).

// .throw, and .return methods.

// 0 -> Array#forEach

// 0b111111111111111111111111111111

// 1 -> Array#map

// 1) "delayed", 2) "initial render", 3) "retry".

// 1) Nobody should add any instance methods on this. Instance methods can be

// 18.2.4 parseFloat(string)

// 18.2.5 parseInt(string, radix)

// 19.1.2.1 Object.assign(target, source, ...)

// 19.1.2.11 Object.isExtensible(O)

// 19.1.2.12 Object.isFrozen(O)

// 19.1.2.13 Object.isSealed(O)

// 19.1.2.14 / 15.2.3.14 Object.keys(O)

// 19.1.2.14 Object.keys(O)

// 19.1.2.15 Object.preventExtensions(O)

// 19.1.2.17 Object.seal(O)

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])

// 19.1.2.2 Object.create(O [, Properties])

// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)

// 19.1.2.3 Object.defineProperties(O, Properties)

// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)

// 19.1.2.4 Object.defineProperty(O, P, Attributes)

// 19.1.2.5 Object.freeze(O)

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

// 19.1.2.7 Object.getOwnPropertyNames(O)

// 19.1.2.8 Object.getOwnPropertySymbols(O)

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)

// 19.1.2.9 Object.getPrototypeOf(O)

// 19.1.3.1 Object.assign(target, source)

// 19.1.3.10 Object.is(value1, value2)

// 19.1.3.19 Object.setPrototypeOf(O, proto)

// 19.1.3.6 Object.prototype.toString()

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)

// 19.2.3.6 Function.prototype[@@hasInstance](V)

// 19.2.4.2 name

// 19.4.1.1 Symbol([description])

// 19.4.2.1 Symbol.for(key)

// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14

// 19.4.2.5 Symbol.keyFor(sym)

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

// 19.4.3.5 Symbol.prototype[@@toStringTag]

// 2 -> Array#filter

// 2) Nobody should rely on `instanceof Fiber` for type testing. We should

// 20.1.2.1 Number.EPSILON

// 20.1.2.10 Number.MIN_SAFE_INTEGER

// 20.1.2.12 Number.parseFloat(string)

// 20.1.2.13 Number.parseInt(string, radix)

// 20.1.2.2 Number.isFinite(number)

// 20.1.2.3 Number.isInteger(number)

// 20.1.2.4 Number.isNaN(number)

// 20.1.2.5 Number.isSafeInteger(number)

// 20.1.2.6 Number.MAX_SAFE_INTEGER

// 20.2.1.9 Math[@@toStringTag]

// 20.2.2.11 Math.clz32(x)

// 20.2.2.12 Math.cosh(x)

// 20.2.2.14 Math.expm1(x)

// 20.2.2.16 Math.fround(x)

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])

// 20.2.2.18 Math.imul(x, y)

// 20.2.2.20 Math.log1p(x)

// 20.2.2.21 Math.log10(x)

// 20.2.2.22 Math.log2(x)

// 20.2.2.28 Math.sign(x)

// 20.2.2.3 Math.acosh(x)

// 20.2.2.30 Math.sinh(x)

// 20.2.2.33 Math.tanh(x)

// 20.2.2.34 Math.trunc(x)

// 20.2.2.5 Math.asinh(x)

// 20.2.2.7 Math.atanh(x)

// 20.2.2.9 Math.cbrt(x)

// 20.3.3.1 / 15.9.4.4 Date.now()

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

// 21.1.2.2 String.fromCodePoint(...codePoints)

// 21.1.2.4 String.raw(callSite, ...substitutions)

// 21.1.3.13 String.prototype.repeat(count)

// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

// 21.1.3.25 String.prototype.trim()

// 21.1.3.27 String.prototype[@@iterator]()

// 21.1.3.3 String.prototype.codePointAt(pos)

// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

// 21.1.3.7 String.prototype.includes(searchString, position = 0)

// 21.2.5.14 RegExp.prototype.toString()

// 21.2.5.3 get RegExp.prototype.flags

// 21.2.5.3 get RegExp.prototype.flags()

// 21.2.5.6 RegExp.prototype[@@match](string)

// 21.2.5.9 RegExp.prototype[@@search](string)

// 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)

// 22.1.2.3 Array.of( ...items)

// 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])

// 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])

// 22.1.3.13 Array.prototype.join(separator)

// 22.1.3.13 Array.prototype.keys()

// 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])

// 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])

// 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])

// 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])

// 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])

// 22.1.3.25 Array.prototype.sort(comparefn)

// 22.1.3.29 Array.prototype.values()

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

// 22.1.3.30 Array.prototype[@@iterator]()

// 22.1.3.31 Array.prototype[@@unscopables]

// 22.1.3.4 Array.prototype.entries()

// 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

// 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

// 23.1 Map Objects

// 23.1.3.1 Map.prototype.clear()

// 23.1.3.3 Map.prototype.delete(key)

// 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

// 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)

// 23.1.3.6 Map.prototype.get(key)

// 23.1.3.7 Map.prototype.has(key)

// 23.1.3.9 Map.prototype.set(key, value)

// 23.2 Set Objects

// 23.2.3.1 Set.prototype.add(value)

// 23.2.3.2 Set.prototype.clear()

// 23.2.3.4 Set.prototype.delete(value)

// 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)

// 23.2.3.7 Set.prototype.has(value)

// 23.3.3.2 WeakMap.prototype.delete(key)

// 23.3.3.3 WeakMap.prototype.get(key)

// 23.3.3.4 WeakMap.prototype.has(key)

// 23.3.3.5 WeakMap.prototype.set(key, value)

// 23.4 WeakSet Objects

// 23.4.3.1 WeakSet.prototype.add(value)

// 23.4.3.3 WeakSet.prototype.delete(value)

// 23.4.3.4 WeakSet.prototype.has(value)

// 24.1.3.1 ArrayBuffer.isView(arg)

// 24.1.4.3 ArrayBuffer.prototype.slice(start, end)

// 24.3.2 JSON.stringify(value [, replacer [, space]])

// 24.3.3 JSON[@@toStringTag]

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

// 25.4.1.5 NewPromiseCapability(C)

// 25.4.3.1 Promise(executor)

// 25.4.4.1 Promise.all(iterable)

// 25.4.4.4 Promise.race(iterable)

// 25.4.4.5 Promise.reject(r)

// 25.4.4.6 Promise.resolve(x)

// 25.4.5.1 Promise.prototype.catch(onRejected)

// 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)

// 26.1.10 Reflect.isExtensible(target)

// 26.1.11 Reflect.ownKeys(target)

// 26.1.12 Reflect.preventExtensions(target)

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])

// 26.1.14 Reflect.setPrototypeOf(target, proto)

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)

// 26.1.4 Reflect.deleteProperty(target, propertyKey)

// 26.1.5 Reflect.enumerate(target)

// 26.1.6 Reflect.get(target, propertyKey [, receiver])

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)

// 26.1.8 Reflect.getPrototypeOf(target)

// 26.1.9 Reflect.has(target, propertyKey)

// 3 -> Array#some

// 3) We might want to experiment with using numeric keys since they are easier

// 30 is the max length we can store without overflowing, taking into

// 4 -> Array#every

// 4) We can easily go from a constructor to a createFiber object literal if that

// 5 -> Array#find

// 5) It should be easy to port this to a C struct and keep a C implementation

// 6 -> Array#findIndex

// 7.1.1 ToPrimitive(input [, PreferredType])

// 7.1.13 ToObject(argument)

// 7.1.15 ToLength

// 7.1.4 ToInteger

// 7.2.1 RequireObjectCoercible(argument)

// 7.2.2 IsArray(argument)

// 7.2.8 IsRegExp(argument)

// 7.2.9 SameValue(x, y)

// 7.3.20 SpeciesConstructor(O, defaultConstructor)

// 7.4.6 IteratorClose(iterator, completion)

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)

// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire

// <- awaiting reactions

// <- checked in isUnhandled reactions

// <- done

// <- index

// <- key

// <- next entry

// <- previous entry

// <- rejection state, 0 - default, 1 - handled, 2 - unhandled

// <- state

// <- value

// <div {...props} key="Hi" />, because we aren't currently able to tell if

// <select> value update needs to occur after <option> children

// @@iterator function is called on it. Some browsers' implementations of the

// @@match logic

// @@replace logic

// @@search logic

// @@split logic

// @see http://www.quirksmode.org/js/events_properties.html

// @see https://electronjs.org/docs/api/webview-tag

// A .throw or .return when the delegate iterator has no .throw

// A C0 control is a code point in the range \u0000 NULL to \u001F

// A Generator should always return itself as the iterator object when the

// A cursor to a boolean indicating whether the context has changed.

// A cursor to the current merged context object on the stack.

// A few React string attributes have a different name.

// A fiber was deleted from this parent fiber, but it's still part of

// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or

// A lane is said to be entangled with another when it's not allowed to render

// A lazy component only mounts if it suspended inside a non-

// A legacy mode Suspense quirk, only relevant to hook components.

// A reserved attribute.

// A safety way is to access one of the cross origin properties: Window or Location

// A simple string attribute.

// A store was mutated in an interleaved event. Render again,

// ATTENTION

// Accessing the contentDocument of a HTMLIframeElement can cause the browser

// Accumulate all instances and listeners via the target -> root path.

// Add all children to a key map for quick lookups.

// Add an extra top frame while an element is being validated

// Add the remaining children to a temporary map so that we can find them by

// Add these to use same hidden class in VM as ServerContext

// After these have been cleaned up, we'll let them throw.

// After this we'll use a set of heuristics to determine whether this

// After we process that Profiler, we'll bubble further up.

// All of the above are perceived as null.

// All remaining items in the tail are insertions.

// All tasks are delayed, and this is the task with the earliest delay.

// All transitions within the same event are assigned the same lane.

// Allow null for conditional declaration

// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.

// Already timed out, so perform work without checking if we need to yield.

// Also helps ensure this is inlined.

// Also validate hook order for cascading updates.

// Although both of these would be inferior to native scheduling.

// Always call this before exiting `commitRoot`, to ensure that any

// Always collect profile timings when DevTools are present.

// Always set children to the same thing. In IE9, the selection range will

// An anonymous function generally suggests a pattern like:

// An update was scheduled from inside a reducer. Add the new

// And by spending extra time finishing it, we're increasing the amount of

// Any existing children that weren't consumed above were deleted. We need

// Any insertions at the end of the tail list after this point

// Anything idle priority or lower should never expire.

// Anything lower than normal priority should remain at the current level.

// Append a new context item.

// Append pending updates to base queue

// Append the captured update the end of the cloned list.

// Append the rendered row to the child list.

// Append the update to the end of the list.

// Append to the beginning of the list.

// Append to the end of the list

// Append to the end of the list.

// Apply the diff to the DOM node.

// Apply the diff.

// Array#includes uses SameValueZero equality algorithm

// Array#indexOf ignores holes, Array#includes - not

// As a result though, React will see the scheduled update as a noop and bailout.

// As a workaround to support multiple concurrent renderers, we categorize

// Assign the result of the finished delegate to the temporary

// Assigning this to a const so Flow knows it won't change in the closure

// Assume that discrete update microtasks are non-cancellable and null.

// Assumes there is no parent namespace.

// Assumes timestamps are monotonically increasing.

// AsyncIterator objects; they just return a Promise for the value of

// AsyncMode is deprecated along with isAsyncMode

// AsyncMode should be deprecated

// At the end of the current render, this queue's interleaved updates will

// At the same time we're going to reverse the list of everything

// At this point layout effects have already been destroyed (during mutation phase).

// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.

// Attach a ping listener

// Attach our event handlers

// Attempt to complete the current unit of work, then move to the next

// Attempt to increase the priority of this target.

// Attempting the main content

// Attributes that aren't in the filter are presumed to have this type.

// Avoid an extra prototype jump for these methods.

// Avoid an infinite loop

// Avoid failures from read-only properties

// Avoid propagating failures to Promises returned by later

// Avoid recreating masked context unless unmasked context has changed.

// Avoid setting value attribute on submit/reset inputs as it overrides the

// B.2.3.10 String.prototype.link(url)

// B.2.3.11 String.prototype.small()

// B.2.3.12 String.prototype.strike()

// B.2.3.13 String.prototype.sub()

// B.2.3.14 String.prototype.sup()

// B.2.3.2 String.prototype.anchor(name)

// B.2.3.3 String.prototype.big()

// B.2.3.4 String.prototype.blink()

// B.2.3.5 String.prototype.bold()

// B.2.3.6 String.prototype.fixed()

// B.2.3.7 String.prototype.fontcolor(color)

// B.2.3.8 String.prototype.fontsize(size)

// B.2.3.9 String.prototype.italics()

// Batching is necessary here in order to ensure that all event handlers run

// Be forgiving, per 25.3.3.3.3 of the spec:

// Because the contents of the boundary haven't started rendering

// Because this fiber did not complete, don't reset its lanes.

// Before committing the children, track on the stack whether this

// Before entering the begin phase, clear pending update priority.

// Before entering the begin phase, copy the work-in-progress onto a dummy

// Before exiting, make sure there's a callback scheduled for the next

// Before rendering again, save the errors from the previous attempt.

// Before starting, find the nearest host parent on the stack so we know

// Before this exception was thrown, there should be `console.error` output

// Browser does not implement `key`, polyfill as much of it as we can.

// Browsers introduced an intervention, making these events

// Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

// Browsers support silencing uncaught errors by calling

// Browsers without "deltaMode" is reporting in raw wheel delta where one

// Bubble times to the next nearest ancestor Profiler.

// Bubble up the earliest expiration time.

// Built-in properties that belong on the element

// But also, it runs earlier which is the semantic we want.

// But it's nice for anonymous functions to inherit the name,

// But the other case is portals, which need to be detached no matter how

// But we shouldn't call any lifecycle methods or callbacks. Remove

// But works for yielding (the common case) and should support resuming.

// By default, return `true` to log errors to the console.

// CONCATENATED MODULE: ./node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js

// CONCATENATED MODULE: ./node_modules/@emotion/memoize/dist/emotion-memoize.esm.js

// CONCATENATED MODULE: ./node_modules/@emotion/stylis/dist/stylis.browser.esm.js

// CONCATENATED MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js

// CONCATENATED MODULE: ./src/components/App/styles.ts

// CONCATENATED MODULE: ./src/index.tsx

// CSP to forbid Function, and you're not willing to fix either of those

// Cache and clear the transitions flag

// Cache unmasked context so we can avoid recreating masked context unless necessary.

// Calculate the diff between the two objects.

// Call delegate.iterator[context.method](context.arg) and handle the

// Called during render to determine if anything has suspended.

// Calling defineProperty() again should be equivalent.

// Calling this function outside this module should only be done for backwards

// Cancel an existing timeout.

// Cancel the existing callback. We'll schedule a new one below.

// Capture and retry

// Capture errors so they don't interrupt mounting.

// Capture errors so they don't interrupt unmounting.

// Captured a suspense effect. Re-render the boundary.

// Captured updates are updates that are thrown by a child during the render

// Careful: RN currently depends on this prefix

// Cast `value` to a string to ensure the value is set correctly. While

// Caution: React DevTools currently depends on this property

// Certain renderers require commit-time effects for initial mount.

// Check for entangled lanes and add them to the batch.

// Check for tasks that are no longer delayed and add them to the queue.

// Check if any lanes are being starved by other work. If so, mark them as

// Check if both types have a family and it's the same one.

// Check if browser support events with passive listeners

// Check if module is in cache

// Check if previous string ref matches new string ref

// Check if the children have any pending work.

// Check if the context matches.

// Check if the lane we chose is suspended. If so, that indicates that we

// Check if the susbcribe function changed. We can save some memory by

// Check if the work completed or if something threw.

// Check if the work-in-progress queue is a clone.

// Check if there are any effects in the whole tree.

// Check if there are updates that we skipped tree that might have unblocked

// Check if there was a render phase update

// Check if there was an insertion or update in the hidden subtree.

// Check if there's an existing task. We may be able to reuse it.

// Check if there's remaining work on this root

// Check if this child belongs to a list of muliple children in

// Check if this host node is stable or about to be placed.

// Check if this is a client root

// Check if this render may have yielded to a concurrent event, and if so,

// Check if this target is unblocked. Returns true if it's unblocked.

// Check if we reverted to client rendering (e.g. due to an error)

// Check if we're dealing with a real forwardRef. Don't want to crash early.

// Check that the browser supports the APIs we need to implement our special

// Children can be more than one argument, and those are transferred onto

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec

// Chrome and IE fire non-standard event when selection is changed (and

// Chrome raises "The specified value <x> is not a valid email address".

// Circular

// Clear ContentReset from the effect tag

// Clear cyclical Fiber fields. This level alone is designed to roughly

// Clear the "placement" from effect tag so that we know that this is

// Clone from the current hook.

// Clone the dependencies object. This is mutated during the render phase, so

// Clone the update queue from current. Unless it's already a clone.

// Command keys insert or clear IME input.

// Commit the effects

// Commit the placeholder.

// Commit the work prepared earlier.

// Compare sort index first, then task id.

// Completing this fiber spawned new work. Work on that next.

// Computes the next Just Noticeable Difference (JND) boundary.

// Conceptually the HostRoot fiber is a child of the Container node. So if you

// Conceptually this is similar to Placement in that a new subtree is

// Conceptually, it's part of the return value of renderWithHooks; it's only a

// Conditionally inject these hooks only if Timeline profiler is supported by this build.

// Confirm that a static flag was not added or removed since the last

// Confirm we haven't re-entered another `act` scope, in case

// Confirmed that the boundary is in a concurrent mode tree. Continue

// Connect to the new tree.

// Consider removing.

// Context is created before the class component is instantiated so check for instance.

// Context list has a pending update. Mark that this fiber performed work.

// Context providers should defer to sCU for rendering

// Continue with the normal Suspense path.

// Contrary to `setAttribute`, object properties are properly

// Controlled attributes are not validated

// Convince Flow we've calculated it (it's DEV-only in this method.)

// Count of children found in the current subtree.

// Count the number of times the root synchronously re-renders without

// Create a fake event type.

// Create a global error event handler. We use this to capture the value

// Create a new module (and put it into the cache)

// Create an event handler for our fake event. We will synchronously

// Create the script via .innerHTML so its "parser-inserted" flag is

// Currently this is only used with renderSubtreeIntoContainer; not sure if it

// Currently, key can be spread in as a prop. This causes a potential

// Cycle through the lanes, assigning each new transition to the next lane.

// DEV mode, we create a separate object for Context.Consumer that acts

// DEV version of invokeGuardedCallback

// DEV-only fields

// DOM after hydrating, and there are boundaries in the DOM

// DOM and Worker environments.

// DOM attribute, CSS property, string ref, etc.) and when React tried to

// DOM component is still mounted; update

// DOM node, and call the user-provided callback from inside an event handler

// DOM properties, then it is an invalid aria-* attribute.

// Dedup strategy: Warn once per component.

// Dedupe by the rendering component because it's the one that needs to be fixed.

// Dedupe strategy: Warn once per component.

// Default

// Default priority updates should not interrupt transition updates. The

// Default to shallow comparison

// Defaults

// Defensive coding. This is never expected to happen.

// Define Generator.prototype.{next,throw,return} in terms of the

// Define iterator

// Define the unified helper method that is used to implement .next,

// Delay having to do this as long as the suspense timeout allows us.

// Delegate to the injected renderer-specific implementation

// Delete all nodes within this suspense boundary.

// Delete the fallback child fragment

// Delete the old fiber and place the new one.

// Deletion effects fire in parent -> child order

// Deletions effects can be scheduled on any fiber type. They need to happen

// Deliberately forget the last sent value so that we don't

// Despite the naming that might imply otherwise, this method only

// Detach the insertion after the last node that was already

// Detached fibers have their state node cleared out.

// Determine the next lanes to work on, and their priority.

// Determine the next lanes to work on, using the fields stored

// DevTools exists, even though it doesn't support Fiber.

// Didn't match.

// Disable this warning in legacy mode, because legacy Suspense is weird

// Disconnect from the old current.

// Disconnect the alternate pointers.

// Disconnect the tail rows after the content row.

// Dispatch the exception by looping back around to the

// Do a pass over the next row.

// Do not assign value if it is already set. This prevents user text input

// Do not pop unless this Fiber provided the current context.

// Do not reset the effect list.

// Do not reset these values until the next render so DevTools has a chance to read them first.

// Do not set `select.value` as exact behavior isn't consistent across all

// Do some typechecking here since we call this blindly. We want to ensure

// Do this as early as possible, so it is queued before anything else that

// Don't bother comparing lengths in prod because these arrays should be

// Don't bother with a very short suspense time.

// Don't bubble properties for hidden children unless we're rendering

// Don't bubble properties in this case.

// Don't change these two values. They're used by React Dev Tools.

// Don't count time spent in a timed out Suspense subtree as part of the base duration.

// Don't deduplicate because this legitimately causes bugs

// Don't enum bug & hidden keys

// Don't fire the event while the user is dragging. This matches the

// Don't need to call updateMouseMovementPolyfillState() here

// Don't persist the state accumulated from the render phase updates to

// Don't push this Fiber's context unless it's unique.

// Don't replay errors if we are hydrating and have already suspended or handled an error

// Don't replay promises.

// Don't reset current debug fiber, since we're about to work on the

// Don't return HostRoot or SuspenseComponent here.

// Don't return anything

// Don't return anything.

// Don't scan deeper if this is a matching provider

// Don't update "base" render times for bailouts.

// Don't warn about react-lifecycles-compat polyfilled components.

// Don't warn about react-lifecycles-compat polyfilled methods though.

// Don't warn in exotic cases like chrome-extension://.

// Drag-and-Drop Attributes

// Due to this, it is left to the user to implement at this time.

// Dummy constructor functions that we use as the .constructor and

// During hydration, the useId algorithm needs to know which fibers are

// During mounting we don't know the child context yet as the instance doesn't exist.

// During the first pass, we'll bail out and not drill into the children.

// ECMAScript 6 symbols shim

// ES3:

// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js

// EXTERNAL MODULE: ./node_modules/react-dom/index.js

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js

// Each 5 bit sequence corresponds to a single base 32 character. So for

// Early bailout if there's no pending work left.

// Edge fails with "Object expected" in some scenarios.

// Effectively, this gives us try-catch behavior without actually using

// Effects

// Electron ships a custom <webview> tag to display external web content in

// Enables DevTools to append owner stacks to error messages in DEV mode.

// Enables DevTools to detect reconciler version rather than renderer version

// Ensure we have the right element, and that the user is not dragging a

// Ensure we transfer the update queue to the parent so that it doesn't

// Error was thrown at the root. There is no parent, so the root

// Especially since these might also just pop in during future commits.

// Even better would be if children weren't special cased at all tho.

// Even if queue.lanes already include lane, we don't know for certain if

// Even if this property uses a namespace we use getAttribute

// Even though the user may not be affected by this error, we should

// Even though we can't restart right now, we might get an

// Even when hot reloading, allow dependencies to stabilize

// Events are not possible without cancelling IME.

// Eventually we'll delete this branch altogether.

// Everything else is already either a hydration lane, or shouldn't

// Exception thrown outside of any try block that could handle

// Execute the module function

// Exiting the outermost act scope. Flush the queue.

// Expect IME keyCode on each keydown. If we get any other

// Expected to be working on a non-root fiber. This is a fatal error

// Experimental Create Event Handle API.

// Extra space so second column lines up

// Extract the VM specific prefix used by each line.

// FF does not set `charCode` for the Enter-key, check against `keyCode`.

// FF fix

// FIXME: What if the suspended lanes are Idle? Should not restart.

// Fabric (secondary); React DOM (primary) and React ART (secondary).

// Failing to do this will result in unnecessary calls to componentWillReceiveProps.

// Fall back to the production implementation.

// Fall through to normal Suspense path

// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).

// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).

// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).

// Fallback to just using the name if we couldn't make it throw.

// Fallback to nativeEvent.srcElement for IE9

// Falling back to client rendering. Because this has performance

// Fast path. We can bail out without scheduling React to re-render.

// Fiber

// Figure out why and fix it. It's not causing any known issues (probably

// Finally, we flush all the warnings

// Finally, we need to push the host context to the stack.

// FireFox implements `key` but returns `MozPrintableKey` for all

// Firefox creates a click event on right mouse clicks. This removes the

// Firefox creates a keypress event for function keys too. This removes

// Firefox doesn't support selectionchange, so check selection status

// First calculate how many bits in the base id represent a complete

// First clear any existing content.

// First, Legacy Mode has different semantics for backwards compatibility. The

// First, let's check if we're in an unusual parsing mode...

// First, validate keys.

// Fix browsers whose `exec` methods don't consistently return `undefined`

// Fix native

// Flag the module as loaded

// Flag this event loop as needing state restore.

// Flip backward selections, so we can set with a single range.

// Flip isDehydrated to false to indicate that when this render

// Flip this back to false.

// Flow does not allow string concatenation of most non-string types. To work

// Flow doesn't know this is unreachable, but eslint does

// Flow knows about invariant, so it complains if I add a break

// Flush any pending passive effects before deciding which lanes to work on,

// Flush the first scheduled "update".

// Flush the immediate callbacks that were scheduled during this batch.

// Flush the queue in a microtask.

// Flush the synchronous work now, unless we're already working or inside

// Focused number inputs synchronize on blur. See ChangeEventPlugin.js

// Focusing a node can change the scroll position, which is undesirable

// For HTML, certain tags should omit their close tag. We keep a list for

// For IE8 and IE9.

// For all other deleted properties we add it to the queue. We use

// For any other property we always add it to the queue and then we

// For backwards compatibility with pre-hooks code, legacy mode only

// For each wakeable, attach a listener so that when it resolves, React

// For example, SuspenseList coordinates when nested content appears.

// For hydration we reuse the update path but we treat the oldProps

// For input and textarea we current always set the value property at

// For now we reuse the whole bag of options since they contain

// For now, the "id" of stateful hooks is just the stateful hook index.

// For number inputs, the display value loses trailing decimal points. For email inputs,

// For other native event types, do nothing.

// For simplicity, reapply `defaultValue` if `multiple` is toggled.

// For text content children we compare against textContent. This

// For the native GeneratorFunction constructor, the best we can

// For those exceptions where entanglement is semantically important, like

// Force a re-render if the implementation changed due to hot reload:

// Force a re-render.

// Forks can return `false` if this isn't desirable.

// Fortunately this only impacts DEV builds.

// ForwardRef is special because its resolved .type is an object,

// Found a pending lane with no expiration time. If it's not suspended, or

// Found an inconsistent store.

// Found it!

// Freeze the next style object so that we can assume it won't be

// GenStateExecuting and loop back for another invocation.

// Give the component that originally created this child.

// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.

// Guard against Fiber being unmounted.

// HTML

// HTML and attributes. Ideally we should preserve structure but it's

// HTML parsing normalizes CR and CRLF to LF.

// Handle listeners that are on HostComponents (i.e. <div>)

// Handle object types

// Helper for defining the .next, .throw, and .return methods of the

// Helpers to patch console.logs to avoid logging during side-effect free

// Here we check to see if the defaultValue has actually changed, avoiding these problems

// Host component type is the display name (e.g. "div", "View")

// Host root, text node or just invalid type.

// HostRoot back. To get to the HostRoot, you need to pass a child of it.

// Hot reloading is disabled.

// However, as a principle, we should aim to make the behavior consistent

// However, if we're currently inside a spawned render, then we need to mark

// However, since the HostRoot starts out with an alternate it might

// However, since we're going to remain on the fallback, we no longer want

// However, the browser would have silenced the original error

// However, we already warn about bad casing elsewhere.

// However, we can't just call getRootHostContext() and push it because

// I.e. if we had null values before, then we want to defer this

// IE 11 parses & normalizes the style attribute as opposed to other

// IE 11 uses modern selection, but doesn't support the extend method.

// IE 8 has a broken Object.defineProperty that only works on DOM objects.

// IE 8- don't enum bug keys

// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)

// IE does not have innerHTML for SVG nodes, so instead we inject the

// IE fires the `keypress` event when a user types an emoji via

// IE specific).

// IE. This event does not support bubbling or cancelling, and

// IE11 WeakMap frozen keys fix

// IE7-

// IE8 does not implement `charCode`, but `keyCode` has the correct value.

// IE8 returns string on undefined

// IE8-

// IE9 claims to support the input event but fails to trigger it when

// IEEE754 conversions based on https://github.com/feross/ieee754

// INFORMATION SEPARATOR ONE, inclusive:

// Ideally this should reset to previous but this shouldn't be called in

// Ideally we would have a special version of the work loop only

// If A is deeper, crawl up.

// If B is deeper, crawl up.

// If `getSnapshot` throws, return `false`. This will schedule

// If `outerNode` has children, this is always the second time visiting

// If `rootNode.form` was non-null, then we could try `form.elements`,

// If `separator` is not a regex, use native split

// If a component has string refs, we will assign a different object later.

// If a component throws an error, we replay it again in a synchronously

// If a controlled event was fired, we may need to restore the state of

// If a dehydrated suspense boundary is in this subtree, we don't know

// If a rejected Promise was yielded, throw the rejection back

// If a scheduler task throws, exit the current browser task so the

// If a value is not provided, then the children must be simple.

// If additional passive effects were scheduled, increment a counter. If this

// If an SVG prop is supplied with bad casing, it will

// If an error occurred during hydration, discard server response and fall

// If an exception is thrown from innerFn, we leave state ===

// If an update was already in progress, we should schedule an Update

// If any entangled lanes are no longer pending on the root, then they

// If any entangled lanes are no longer pending on the root, then they must

// If attribute type is boolean, we know for sure it won't be an execution sink

// If both copies of the parent fiber point to the same child, we can

// If change and propertychange bubbled, we'd just bind to it like all the

// If changes to the hydrated node need to be applied at the

// If completing this work spawned new work, do that next. We'll come

// If componentDidCatch is the only error boundary method defined,

// If composition event is available, we extract a string only at

// If console.error is overridden, or logCapturedError() shows a dialog that throws,

// If context.method was "throw" but the delegate handled the

// If controlled, assign the value attribute to the current value on blur

// If document doesn't exist we know for sure we will crash in this method

// If enqueue has been called before, then we want to wait until

// If it is not host node and, we might have a host node inside it.

// If it needs to be retried, it should have work scheduled on it.

// If it was the primary children that just suspended, capture and render the

// If it's a spacebar character, assume that we have already handled

// If it's not a container, we check if it's an instance.

// If layout work was scheduled, flush it now.

// If new component APIs are defined, "unsafe" lifecycles won't be called.

// If no characters are being inserted, no BeforeInput event should

// If no event plugins have been injected, we are in a server environment.

// If no state update is scheduled then the boundary will swallow the error.

// If none of the children had any work, that means that none of

// If nothing suspended before and we're rendering the same children,

// If nothing suspended, we need to schedule an effect to mark this boundary

// If nothing threw a Promise or all the same fallbacks are already showing,

// If other browsers ever implement it, it's better to use it.

// If our component frame is labeled "<anonymous>"

// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.

// If passive option is not supported, then the event will be

// If props or context changed, mark the fiber as having performed work.

// If shouldComponentUpdate returned false, we should still update the

// If so, we need to hide those nodes in the commit phase, so

// If something asked for a stack inside a fake render, it should get ignored.

// If something inside a portal is clicked, that click should bubble

// If something suspended, schedule an effect to attach retry listeners.

// If something threw an error, try rendering one more time. We'll

// If something threw an error, try rendering one more time. We'll render

// If something throws, leave the remaining callbacks on the queue.

// If something was in fallback state last time, and we have all the

// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.

// If that inner render function is different, we'll build a new forwardRef type.

// If the boundary is in legacy mode, we should *not*

// If the delegate iterator has a return method, give it a

// If the direct event target isn't a React owned DOM node, we need to look

// If the dispatched exception was caught by a catch block,

// If the error was thrown during hydration, we may be able to recover by

// If the fallback does commit, we need to attach a different type of

// If the instance does not exist yet, we will push null at first,

// If the left or right node is smaller, swap with the smaller of those.

// If the passive effects are the result of a discrete render, flush them

// If the root is not a host container, we're in a disconnected tree. I.e.

// If the root or lanes have changed, throw out the existing stack

// If the tail is hidden there might not be an Suspense boundaries

// If the target node is part of a hydrated or not yet rendered subtree, then

// If the text differs, mark it as an update. All the work in done in commitWork.

// If the update payload indicates that there is a change or if there

// If the update was already committed, we should not queue its

// If the value is an error, call this function immediately after it is thrown

// If there are any suspended transitions, it's possible this new update

// If there are pending passive effects, schedule a callback to process them.

// If there is a ref on a host node we need to schedule a callback

// If there is more work to do in this returnFiber, do that next.

// If there is no alternate, then we only need to check if it is mounted.

// If there is no alternate, this might be a new tree that isn't inserted

// If there were legacy sync updates, flush them at the end of the outer

// If there's a current queue, and it's different from the base queue, then

// If there's ambiguity due to batching it's resolved in preference of:

// If there's more work, schedule the next message event at the end

// If there's no match, maybe there will be one further down in the child tree.

// If there's no parent, we're at the root.

// If there's no remaining work, we can clear the set of already failed

// If they don't match there's a potential tear and a full deopt render is required.

// If they were previously forced into fallbacks, they may now be able

// If this boundary has already errored, then we had trouble processing

// If this boundary is currently timed out, we need to decide

// If this boundary just timed out, then it will have a set of wakeables.

// If this doesn't spawn new work, complete the current work.

// If this happens during a replay something went wrong and it might block

// If this is a controlled radio button group, forcing the input that

// If this is a fresh new component that hasn't been rendered yet, we

// If this is a newly suspended tree, it might not get committed as

// If this is a plain function component without default props,

// If this is an aria-* attribute, but is not listed in the known DOM

// If this is an initial render of a new tree of Suspense boundaries and

// If this is an over event with a target, we might have already dispatched

// If this is hard to grasp, it might help to intentionally break this

// If this is the second pass of an error or suspense boundary, there

// If this offscreen component is hidden, we already unmounted it. Before

// If this update is a state update (not a reducer) and was processed eagerly,

// If this was a boolean, it doesn't matter what the value is

// If this was a forced client render, there may have been

// If those values are changed that package should be rebuilt and redeployed.

// If we already suspended with a delay, then interrupting is fine. Don't

// If we are currently composing (IME) and using a fallback to do so,

// If we are currently inside another batch, we need to wait until it

// If we are only accumulating events for the target, then we don't

// If we are processing the onBeforeBlur event, then we need to take

// If we are using the legacy FB support flag, we

// If we bailout on this work, we'll move them back (like above).

// If we can't hydrate this instance let's try the next one.

// If we captured an error, but getDerivedStateFromError is not defined,

// If we didn't find any host children, fallback to closest host parent.

// If we didn't find anything, let's try the next sibling.

// If we didn't hit the root, that means that we're in an disconnected tree

// If we don't find a Fiber on the comment, it might be because

// If we don't have a child, try the siblings instead.

// If we don't have any more existing children we can choose a fast path

// If we find that "rootContainer", we find the parent fiber

// If we get an event (ex: img onload) before committing that

// If we get updated because one of our children updated, we don't

// If we had a single constructor, it would be megamorphic and engines would deopt.

// If we had additional state updates during this life-cycle, let's

// If we have a mismatch, it might be caused by that.

// If we have already queued this exact event, then it's because

// If we have an alternate, that means this is an update and we need

// If we have an alternate, that means this is an update and we need to

// If we have any remaining hydratable nodes, we need to delete them now.

// If we have pending work still, associate the original updaters with it.

// If we have pending work still, restore the original updaters

// If we have scheduled higher pri work above, this will probably just abort the render

// If we have two possible branches, we'll walk backwards up to the root

// If we haven't fully disabled javascript: URLs, and if

// If we hit a "Delayed" case, such as when we'd switch from content back into

// If we hydrated, then we'll need to schedule an update for

// If we pop out of the root or hit the parent the fiber we are the

// If we previously forced a fallback, we need to schedule work

// If we the instance doesn't have any children, then there can't be

// If we unwrapped and compared the inner types for wrappers instead,

// If we're about to return the first line, and the control is also on the same

// If we're already in the middle of a render, switching lanes will interrupt

// If we're already showing a fallback and it gets "retried", allowing us to show

// If we're already showing a fallback, there are cases where we need to

// If we're currently hydrating, try to hydrate this boundary.

// If we're currently inside an `act` scope, bypass Scheduler and push to

// If we're going to re-use an existing task, it needs to exist.

// If we're not currently hydrating but we're in a hydration context, then

// If we're outside a transition, fall through to the regular error path.

// If we're recovering from an error, reconcile without reusing any of

// If we're suspended with delay, or if it's a retry, we'll always suspend

// If we're switching from a direct text child to a normal child, or to

// If you call unmountComponentAtNode twice in quick succession, you'll

// If you ended up here by following an exception call stack, here's what's

// Ignore it and don't print the stack addendum.

// Ignore the finally entry if control is not jumping to a

// Ignore.

// Implicit key determined by the index in the set

// In Chrome, assigning defaultValue to certain input types triggers input validation.

// In DEV mode, we swap out invokeGuardedCallback for a special version

// In DEV, calls to console.warn and console.error get replaced

// In Fiber this, is just the state node right now. We assume it will be

// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the

// In IE9+, we have access to composition events, but the data supplied

// In IE9, propertychange fires for most input events but is buggy and

// In PROD (or in packages without access to React internals),

// In React, we let users pass `true` and `false` even though technically

// In Safari, appending an iframe forces microtasks to run.

// In V8, the first line is describing the message but other VMs don't.

// In a resume, we'll already have an instance we can reuse.

// In a true multi-threaded implementation, we would render children on

// In addition to entangling each of the given lanes with each other, we also

// In case, we're still uninitialized, then we're waiting for the thenable

// In concurrent roots, we throw when there's a text mismatch and revert to

// In development, we provide our own message with just the component stack.

// In either case, we don't want to call the event handler if the value

// In legacy mode, SuspenseList doesn't work so we just

// In legacy mode, we commit the primary tree as if it successfully

// In legacy mode, we flush pending passive effects at the beginning of the

// In legacy sync mode, don't defer the subtree. Render it now.

// In modern browsers, reportError will dispatch an error event,

// In most cases, this console output also shows the component and its

// In most cases, this means every transition gets its own lane, until we

// In older browsers and test environments, fallback to console.error.

// In order to support react-lifecycles-compat polyfilled components,

// In production, always call Scheduler. This function will be stripped out.

// In profiling mode, resetChildExpirationTime is also used to reset

// In such a case, we directly return the `char` property instead of

// In the Fizz implementation this is much simpler because the child is

// In the initial pass we might need to construct the instance.

// In the middle of an update, it is possible to have multiple checked.

// In the second pass, we mount the new children. The trick here is that we

// In this case, the return pointer is also cleared out,

// Include the time spent working on failed children before continuing.

// Increase its priority.

// Increases the priority of thenables when they resolve within this boundary.

// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.

// Initial mount

// Initial mount should not be batched.

// Initializing the fields below to smis and later updating them with

// Inject data generated from fallback path into the synthetic event.

// Inlined `enqueueUpdate` to remove interleaved update check

// Inner memo component props aren't currently validated in createElement.

// Inner propTypes will be validated in the function component path.

// Inner props are checked in the reconciler.

// Inner props for memo are validated later.

// Insert

// Inside `act`, use our internal `act` queue so that these get flushed

// Instance

// Instantiate twice to help detect side-effects.

// Instead of committing the fallback immediately, wait for more data

// Instead of mutating we could clone the event.

// Instead of surfacing the error, find the nearest Suspense boundary

// Instead, we'll leave the content in place and try to hydrate it later.

// Instead, we'll leave work left on it to render it in a separate commit.

// Intentional fallthrough

// Intentional fallthrough to next branch

// Intentionally camelCase

// Intentionally create event lazily.

// Intentionally inside to avoid triggering lazy initializers:

// Intentionally mutating since this render will get interrupted. This

// Intentionally not using a try-catch, since that makes some debugging

// Intentionally not using it yet to derisk the initial implementation, because

// Intentionally pushing one by one.

// Intentionally unsound. Pending updates form a circular list, but we

// Intentionally use the original name.

// Interleaved updates are stored on a separate queue. We aren't going to

// Internal invariant that should never happen, but feasibly could in

// Invoke the function an extra time to help detect side-effects.

// Invokes the mount life-cycles on a previously never rendered instance.

// Invokes the update life-cycles and returns false if it shouldn't rerender.

// Is this lane transitively entangled with the newly entangled lanes?

// Is this one of the newly entangled lanes?

// It also can turn \u0000 into \uFFFD inside attributes.

// It has only been added in Fiber to match the (unintentional) behavior in Stack.

// It is handled by React separately and shouldn't be written to the DOM.

// It is important to unwind the context in the reverse order.

// It might be better to just add a `forks` field to the Fiber type. It would

// It should be kept in sync with the Lanes values above.

// It will get deleted.

// It's also a signal to replay events and the suspense callback.

// It's important to move them now in case the work spawns more work at the same priority with different updaters.

// It's okay to replace the initial doubles with smis after initialization.

// It's still possible that we'll need to rebase this update later,

// It's unlikely their type would change as usually you define them inline.

// Iterate through the list of updates to compute the result.

// Iterator interface in terms of a single ._invoke method.

// Just set it using the onclick property so that we don't have to manage any

// Keep both the (mapped) and old keys if they differ, just as

// Keep flushing work until there's none left.

// Keep in sync with ReactTestUtils.js.

// Keep in sync with react-reconciler/getComponentNameFromFiber

// Keep in sync with shared/getComponentNameFromType

// Keep rendering in a loop for as long as render phase updates continue to

// Keep scanning and use the map to restore deleted items as moves.

// Keep this check inline so it only runs on the false path:

// Keep this code in sync with handleError; any changes here must have

// Keep track of the current Offscreen stack's state.

// Keep track of the start time so we can measure how long the main thread

// Keep working on the existing in-progress tree. Do not interrupt.

// KeyPress is deprecated, but its replacement is not yet final and not

// Known attributes should match the casing specified in the property config.

// Layout effects are destroyed during the mutation phase so that all

// Lazy component props can't be validated in createElement

// Lazy may contain any component type so we recursively resolve it.

// Lazy types should reconcile their resolved type.

// Learn more about this here:

// Leave the child in place. I.e. the dehydrated fragment.

// Leave the existing child in place.

// Legacy Interface

// Legacy Mode Suspense

// Legacy hook: remove it

// Legacy mode doesn't warn if the update is batched, i.e.

// Legacy mode has additional cases where we suppress a warning.

// Let the ARIA attribute hook validate ARIA attributes

// Let's get the fiber associated with the SuspenseComponent

// Let's try everything again

// List of events that need to be individually attached to media elements.

// Live Region Attributes

// Loop through the updates and clone them.

// MS Edge argumentsList argument is optional

// MS Edge converts symbol values to JSON as {}

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false

// Make sure such renderers get scheduled for later work.

// Make sure we're on the second pass, i.e. the primary child fragment was

// Mark any Suspense boundaries with fallbacks as having work to do.

// Mark anything that was blocked on this as no longer blocked

// Mark each child as hydrating. This is a fast path to know whether this

// Mark it as having captured (i.e. suspended).

// Mark that the fiber performed work, but only if the new state is

// Mark that the root has a pending update.

// Mark the children as hydrating. This is a fast path to know whether this

// Mark the current commit time to be shared by all Profilers in this

// Mark the current render as suspended so that we switch to working on

// Mark the parent fiber as incomplete and clear its subtree flags.

// Mark the updated lanes on the list, too.

// Match production behavior more closely:

// Match! Schedule an update on this fiber.

// Math.pow(2, 30) - 1

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.

// Maybe not a big deal since this is DEV only behavior.

// Memo may contain any component type so we recursively resolve it.

// Memoize state using the values we just used to render.

// Memoize using the boundary fiber to prevent redundant listeners.

// Memoize using the thread ID to prevent redundant listeners.

// Merge parent and own context.

// Merge the partial state and the previous state.

// Merge the pending queue and the base queue.

// Microdata

// Mobile Safari does not fire properly bubble click events on

// Mode, SuspenseList can also trigger this scenario, but this is a legacy-

// Modern event system doesn't use pooling.

// Mount

// Move based on index

// Moved outside to ensure DCE works with this flag

// Moving from `node` to its first child `next`.

// Moving from `node` to its next sibling `next`.

// Moving to a node from outside the window.

// Must not discard the (non-)printable Enter-key.

// Mutation mode

// NOTE: This cannot be properly polyfilled in engines that don't support

// NOTE: This is equivalent to

// NOTE: This is set to the corresponding constant as in Scheduler.js.

// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,

// NOTE: This update intentionally doesn't have a payload. We're only using

// Name comes from the type in this case; we don't have a tag.

// Need to check if the tree still needs to be deferred. This is

// Needed because Blocks store data on type.

// Needs a placement effect because the parent (the Suspense

// Needs a placement effect because the parent (the Suspense boundary) already

// Neither child is smaller. Exit.

// Nested Offscreen tree is already hidden. Don't disappear

// Nested Offscreen tree is still hidden. Don't re-appear its effects.

// Never force flush in production. This function should get stripped out.

// New root; bubble back up to here and stop.

// New rows can't be content rows.

// Next we find the first one that isn't the same which should be the

// Next we need to figure out if the node that skipped past is

// Next we'll drill down this component to find the first HostComponent/Text.

// Next we're going to render the tail.

// Next we're simply going to delete all insertions after the

// No DevTools

// No additional work was scheduled. Finish.

// No boundary was found. Unless this is a sync update, this is OK.

// No catch in prod code path.

// No change. Bailout early if children are the same.

// No child. Traverse to next sibling.

// No effects.

// No implementation differences.

// No more siblings. Traverse up.

// No pending update, but because context is propagated lazily, we need

// No pending updates or context. Bail out now.

// No special behavior since these rules fall back to "in body" mode for

// Node.js

// Node.js 0.8-

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:

// Node.js and old IE.

// Noop.

// Normalize SVG <use> element events #4963

// Normalize inconsistent values reported by browsers due to

// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`

// Normally portals handle their own events all the way down to the root.

// Normally we'd only need to check one of the fibers because if it

// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug

// Not currently showing content. Consult the Suspense context.

// Not in an act environment. No need to warn.

// Not sure about the optimal order of these conditions:

// Not used by React but could be by user code:

// Note that simple async functions are implemented on top of

// Note that the "rows" will be workInProgress, but any nested children

// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.

// Note that this will happen even if batchedUpdates is higher up

// Note that this would still prematurely flush the callbacks

// Note that we apply entanglements *after* checking for partial work above.

// Note the use of `==` which checks for null or undefined.

// Note: During these life-cycles, instance.props/instance.state are what

// Note: Memo only checks outer props here.

// Note: The following is done to avoid a v8 performance cliff.

// Note: These happen to have identical begin phases, for now. We shouldn't hold

// Note: This intentionally doesn't check if we're hydrating because comparing

// Note: We don't reset the actualTime counts. It's useful to accumulate

// Note: ["return"] must be used for ES3 parsing compatibility.

// Note: `option.selected` is not updated if `select.multiple` is

// Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.

// Note: memo() and forwardRef() we'll compare outer rather than inner type.

// Note: there is a special case that prevents it from being written to the DOM

// Note: these two variables *must* always be updated together.

// Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

// Nothing to do for these component types

// Nothing to do here. This is terminal. We'll do the completion step

// Nothing to hydrate. Make it an insertion.

// Noticeable Difference.

// Now push the new context and mark that it has changed.

// Now that all the child effects have unmounted, we can remove the

// Now that we know this function doesn't throw, replace it.

// Now that we've validated casing, do not validate

// Now we need to find it's corresponding host fiber in the other

// Number('+0x1') should be NaN, old V8 fix

// OK, the next part is confusing. We're about to reconcile the Suspense

// Offscreen doesn't have the first render pass).

// Offscreen wrapper.

// Old WebKit

// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support

// On some platforms, in particular some releases of Android 4.x,

// On the selectionchange event, the target is just document which isn't

// Once the update queue is empty, persist the derived state onto the

// Only Profilers with work in their subtree will have an Update effect scheduled.

// Only attach a listener if one does not already exist for the lanes

// Only bother fetching default value if we're going to use it

// Only enableCreateEventHandleAPI:

// Only fire when selection has actually changed.

// Only flushes the queue if there's a legacy sync callback scheduled.

// Only hide or unhide the top-most host nodes.

// Only monitor this failure once because there tends to be a lot of the

// Only occurs if the fiber has been unmounted.

// Only reset the updates from the queue if it has a clone. If it does

// Only set node.value if textContent is equal to the expected

// Only true when this component is being hot reloaded.

// Only used when enableSuspenseLayoutEffectSemantics is enabled.

// Or it may be because it's older React where they're the same thing.

// Or the root (for the DevTools Profiler to read)

// Original props are copied

// Otherwise B has to be current branch.

// Otherwise, return to the parent

// Otherwise, the value attribute is synchronized to the property,

// Otherwise, we're going to have to hide content so we should

// Overload the definition to the two valid signatures.

// Parse the HTML and read it back to normalize the HTML string so that it

// Partial state object

// Perform work until Scheduler asks us to yield

// PhantomJS / old WebKit has a broken implementations

// Placement effects (insertions, reorders) can be scheduled on any fiber

// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'

// Plug for library

// Pop a row.

// Portal will bubble through to us.

// Portals are special because we don't append the children during mount

// Prefix to avoid chaos with special keys.

// Prevent bailout if the implementation changed due to hot reload.

// Prevent re-entrance.

// Priority is insufficient. Skip this update. If this is the first

// Probably in the "in body" parsing mode, so we outlaw only tag combos

// Proceed under the assumption that this is a class instance

// Proceed under the assumption that this is a function component

// Process this update.

// Profiler API hooks

// Promise.resolve without an argument throws an error in LG WebOS 2

// Promote the fiber to a class and try rendering again.

// Prop type validation may throw. In case they do, we don't want to

// Propagate layout effect durations to the next nearest Profiler ancestor.

// Push context providers early to prevent context stack mismatches.

// Push current root instance onto the stack;

// Push onto existing queue. Don't need to schedule a callback because

// Push this callback into an internal queue. We'll flush these either in

// Queue the event to be replayed later. Abort dispatching since we

// Rather than returning an object with a next method, we keep

// React DevTools reads this flag.

// React Refresh

// React nodes in the future. We need to check this first because

// React v16.11 and below

// React v16.12 and above

// React$ElementType

// React.Component uses a shared frozen object by default.

// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,

// ReactFiberContext usually updates this cache but can't for newly-created instances.

// Read the current snapshot from the store on every render. This breaks the

// Read this again, since a passive effect might have updated it

// Read this again, since an effect might have updated it

// Received a ping at the same priority level at which we're currently

// Received an update to a tree that's in the middle of rendering. Mark

// Reconsider whether this is necessary.

// Record the characters to be added to the DOM.

// Record the component responsible for creating this element.

// Record the render duration for the fiber that errored.

// Record the time spent rendering before an error was thrown. This

// Recursively delete all host nodes from the parent, detach refs, clean

// Recursively flush the queue until there's no remaining work.

// Recursively traverse the entire deleted tree and clean up fiber fields.

// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416

// Refs should update even if shouldComponentUpdate returns false

// RegExp constructor can alter flags and IsRegExp works correct with @@match

// RegExp[@@split] doesn't call the regex's exec method, but first creates

// Regardless of whether this script is executing as a CommonJS module

// Register a callback to retry this boundary once the server has sent the result.

// Regular boundaries always capture.

// Relationship Attributes

// Relies on `updateStylesByID` not mutating `styleUpdates`.

// Remaining properties are added to a new props object

// Remaining timers are pending.

// Remember the parent context so we can merge with it later.

// Remove our event listeners

// Renderers may schedule work to be done after host components are mounted

// Rendering a hidden tree.

// Rendering at offscreen, so we can clear the base lanes.

// Replace the child/sibling pointers above it.

// Replace the old (or empty) context with the new one.

// Replicate behavior of original `act` implementation in legacy mode,

// Represents whether effect should fire.

// Rerender

// Rerender the whole list, but this time, we'll force fallbacks

// Reserved names are extracted

// Reset a workInProgress child set to prepare it for a second pass.

// Reset all effects except static ones.

// Reset effect durations for the next eventual effect phase.

// Reset module-level state that was set during the render phase.

// Reset the child fibers to their original state.

// Reset the durations from the first pass so they aren't included in the

// Reset the effect flags before doing the second pass since that's now invalid.

// Reset the effect flags but keep any Placement tags, since that's something

// Reset the effect tag.

// Reset the priority to the previous non-sync value.

// Reset the profiler timer.

// Reset the text content of the parent before doing any insertions

// Reset the work-in-progress list

// Reset this to null before calling lifecycles

// Reset to createFiber's initial values.

// Reset to the "together" mode in case we've started a different

// Reset to the cloned values that createWorkInProgress would've.

// Resetting context._sent for legacy support of Babel's

// Resolve default props

// Resolve default props. Taken from ReactElement

// Resolved (SimpleMemoComponent has no defaultProps)

// Resolved for outer only

// Resolved props

// Restart from the root.

// Restart work from the new fiber.

// Restarting too aggressively is also not good because it starves out any

// Restore Offscreen state and resume in our-progress traversal.

// Restore the context.

// Restore the original properties of the fiber.

// Restore the previous values.

// Resume execution at the desired location (see delegateYield).

// Resume flushing in the next tick

// Retaining it forever may interfere with GC.

// Retry if any event replaying was blocked on this.

// Retry listener

// Return an iterator with no values.

// Return the exports of the module

// Return the line we found.

// Return to the normal work loop.

// Return whether there's additional work

// Returns a SuspenseInstance or Container if it's blocked.

// Returns false if we're not sure.

// Returns the SuspenseInstance if this node is a direct child of a

// Returns whether passive effects were flushed.

// Reuse previous dependencies

// Reuse the previous value

// Revert the select back to its default unselected state.

// Revert to client rendering.

// Right before committing, we will walk the tree and check if any of the

// Root is not dehydrated. Either this is a client-only root, or it

// Run beginWork again.

// Run these checks in production only if the flag is off.

// SUSPENSE_x_START_DATA. Otherwise, null.

// SVG

// SVG-related properties

// Safari may fire events on text nodes (Node.TEXT_NODE is 3).

// Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:

// Safe because if current fiber exists, we are reconciling,

// Same as above

// Schedule a Ref effect

// Schedule a callback to attempt replaying as many events as are

// Schedule a deferred render

// Schedule a force update on the work-in-progress.

// Schedule a new callback.

// Schedule a normal pri update to render this content.

// Schedule a passive effect for this Profiler to call onPostCommit hooks.

// Schedule a placeholder to display after a short delay, using the Just

// Schedule a timeout.

// Schedule an effect to attach a retry listener to the promise.

// Schedule an effect to clear this container at the start of the

// Schedule an effect to subscribe to the store.

// Schedule an effect to update the mutable instance fields. We will update

// Schedule the initial render. In a hydration root, this is different from

// Schedule this fiber to re-render at offscreen priority. Then bailout.

// Search parent A's child set

// Search parent B's child set

// Search the rendered tree for external store reads, and check whether the

// Second is hydration. During hydration, the Suspense fiber has a slightly

// Secondary renderers store their context values on separate fields.

// See discussion in https://github.com/facebook/react/pull/10676.

// See discussion in https://github.com/facebook/react/pull/6896

// See https://github.com/facebook/react/issues/11807

// See https://github.com/facebook/react/issues/12995

// See https://github.com/facebook/react/issues/13222

// See https://github.com/facebook/react/pull/19216.

// See https://github.com/facebook/regenerator/issues/274 for more details.

// See rules for 'li', 'dd', 'dt' start tags in

// See the discussion in https://github.com/facebook/react/pull/11157.

// Seems redundant, but it changes the type from a single lane (used for

// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.

// Set @@toStringTag to native iterators

// Set `workInProgress` to null. This represents advancing to the next

// Set a flag to indicate that we should try rendering the normal

// Set the dispatcher in DEV because this might be call in the render function

// Set the remaining expiration time to be whatever is remaining in the queue.

// Set the return pointer of the child to the work-in-progress fiber.

// Set the return pointer of the sibling to the work-in-progress fiber.

// Set this to null to indicate there's no in-progress render.

// Set this to true to indicate that the rendered value is inconsistent

// Set up the Suspense Context to force suspense and immediately

// Setting a size greater than 1 causes a select to behave like `multiple=true`, where

// Setting context._sent for legacy support of Babel's

// Shallow cloning props works as a workaround for now to bypass the bailout check.

// Shift down to normal priority

// Should always be set

// Should this check be gated by parent namespace? Not sure we want to

// Shouldn't skip holes

// Silently steal the ref from the parent.

// SimpleMemoComponent codepath doesn't resolve outer props either.

// Since nothing actually suspended, there will nothing to ping this

// Since the old fiber is disconnected, we have to schedule it manually.

// Since these are SVG attributes, their attribute names are case-sensitive.

// Since this is conceptually a new fiber, schedule a Placement effect

// Since this wasn't the direct target of the event, we might have

// Since we already found a match, we can stop traversing the

// Since we know we're in a React event, we can clear the current

// Since we're restarting, remove anything that is not a host effect

// Since we're reusing a current tree, we need to reuse the flags, too.

// Skip key warning if the type isn't valid since our key validation logic

// Skip non-hydratable nodes.

// Skip past all nodes within this suspense boundary.

// Skip this if we're not updating due to sCU.

// Skipping one frame that we assume is the frame that calls the two.

// So we can clear these now to allow a new callback to be scheduled.

// So we can't tell if the event name is correct for sure, but we can filter

// So we might as well always mark this.

// So we preemptively throw with a better message instead.

// So we push an empty value first. This lets us safely unwind on errors.

// So we should be able to stop now. However, we don't know if this portal

// So we'll skip the misleading extra mismatch warning in this case.

// Some environments might not have setTimeout or clearTimeout.

// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.

// Some of these attributes can be hard to find. This list was created by

// Something errored during hydration. Try again without hydrating.

// Something in the return path also threw.

// Something in this boundary's subtree already suspended. Switch to

// Something may have been mutated in between render and commit. This could

// Something might get unblocked by state updates or retries in the

// Something should be setting the props in the constructor.

// Something suspended and we should still be in dehydrated mode.

// Something suspended. Re-render with the fallback children.

// Something went really wrong, and our event was not dispatched.

// Spec says something about storing a list of markers, but it sounds

// Special case where we suspended while reconciling the children of

// Special case: Sync React callbacks are scheduled on a special

// Special case: There's nothing to work on.

// Special cases

// Special cases where event names don't match.

// Special path for dehydrated boundaries. We may eventually move this

// Special path for hydration

// Stack implementation injected by the current renderer.

// Start over from the beginning of the list

// Stash the eagerly computed state, and the reducer used to compute

// Stash the wakeable on the boundary fiber so we can access it in the

// State object

// Static effects are not specific to a render.

// Store duration on the next nearest Profiler ancestor

// Store the dehydrated fragment as a child fiber.

// Store the unwrapped component in the type.

// Strict effects should never run on legacy roots

// Strictly speaking, seeing an <option> doesn't mean we're in a <select>

// String SVG attributes with the xlink namespace.

// String SVG attributes with the xml namespace.

// String methods call symbol-named RegEp methods

// Submit/reset inputs need the attribute removed completely to avoid

// Subscribe to the store and return a clean-up function.

// Successfully completed a forced client render. The errors that occurred

// Successfully completed this tree. If this was a forced client render,

// Successfully finished rendering on retry

// Support DevTools editable values for useState and useReducer.

// Support DevTools props for function components, forwardRef, memo, host components, etc.

// Support for module components is deprecated and is removed behind a flag.

// Suppress the error. It will throw again in the render phase.

// Suspended but we should no longer be in dehydrated mode.

// Suspense Heuristics

// Suspense boundaries are implemented as multiple fibers, but they

// Suspense boundary, and also after we've reentered it for further hydration.

// Suspense boundary, this will unwind all the way to the root without

// Suspense boundary.

// Suspense layout effects semantics don't change for legacy roots.

// SuspenseInstance. I.e. if its previous sibling is a Comment with

// SuspenseList doesn't actually catch anything. It should've been

// SuspenseList so that it can retry if they resolve.

// Symbol-named RegExp methods call .exec

// Synchronously dispatch our fake event. If the user-provided function

// TODO (Offscreen) Also check: subtreeFlags & LayoutMask

// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)

// TODO (Offscreen) Check: flags & LayoutStatic

// TODO (Offscreen) Check: flags & RefStatic

// TODO (Offscreen) Check: subtreeFlags & LayoutStatic

// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects

// TODO (bvaughn) Replace this behavior with an invariant() in the future.

// TODO Clear this data once all pending hydration work is finished.

// TODO This time should be the time at which the server rendered response that is

// TODO: Assign this to `suspenseState.retryLane`? to avoid

// TODO: Because we don't have a work-in-progress, this will add the

// TODO: Check if fiber has a PassiveStatic flag

// TODO: Clean this up once we turn on the string ref warning for

// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should

// TODO: Consider calling `unwindWork` to pop the contexts.

// TODO: Consider how Offscreen should work with transitions in the future

// TODO: Consider not doing this for input and textarea.

// TODO: Consider unifying this with how the root works.

// TODO: Consider warning about bad polyfills

// TODO: Consider warning in this path if a fallback timer is not scheduled.

// TODO: ContentReset gets cleared by the children during the commit

// TODO: Defer siblings if we're not at the right index for this slot.

// TODO: Delete all other places that schedule the passive effect callback

// TODO: Delete this argument when we remove the legacy root API.

// TODO: Delete this option

// TODO: Determine the best fallback here.

// TODO: Disabled elements should not respond to mouse events

// TODO: Distinguish by namespace here -- for <title>, including it here

// TODO: Do we still need to entangle transitions in this case?

// TODO: Don't need to accumulate this. Instead, we can remove

// TODO: Don't need to accumulate this. Instead, we can remove renderLanes

// TODO: Don't need to reset the flags here, because they're reset in the

// TODO: Drop this when these are no longer allowed as the type argument.

// TODO: Ensure that an update gets scheduled if any of the special props

// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.

// TODO: Find a more efficient way to do this.

// TODO: For the shouldClone case, this could be micro-optimized a bit by

// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.

// TODO: Handle wasCustomComponentTag

// TODO: I found and added this missing line while investigating a

// TODO: I think this is now always non-null by the time it reaches the

// TODO: I think we can remove this, since we now use `DidCapture` in

// TODO: Ideally this would inherit the event time of the current render

// TODO: If deps are provided, should we skip comparing the ref itself?

// TODO: If key === null and child.key === null, then this only applies to

// TODO: If the tree is hidden, in most cases we should be able to skip

// TODO: If this is a HostRoot we might want to bail out.

// TODO: If this is the first discrete event in the queue. Schedule an increased

// TODO: If we're rendering sync either due to Sync, Batched or expired,

// TODO: If workInProgress.child is null, we can continue on the tail immediately.

// TODO: Include link to relevant documentation page.

// TODO: Instead of searching up the fiber return path on every deletion, we

// TODO: Is the JND optimization worth the added complexity? If this is

// TODO: Is this necessary anymore? The only user code that runs in this

// TODO: It's possible that even a concurrent render may never have yielded

// TODO: Lol maybe there's a better way to factor this besides this

// TODO: Make sure that we check isMounted before firing any of these events.

// TODO: Make sure this doesn't override pings that happen while we've

// TODO: Make sure we check if this is still unmounted or do any clean

// TODO: Might be better if `flushPassiveEffects` did not automatically

// TODO: Move createInstance to beginWork and keep it on a context

// TODO: Move out of the loop. This only happens for the first run.

// TODO: Move the reset at in beginWork out of the common path so that

// TODO: Move this and createInstance step into the beginPhase

// TODO: Move this to FiberRoot constructor

// TODO: Move this to passive phase

// TODO: Move this type conversion to the event priority module.

// TODO: Move to ReactFiberConcurrentUpdates?

// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.

// TODO: Move to commitPassiveMountEffects

// TODO: Move to passive phase

// TODO: Not spec compliant, should be false.

// TODO: Not sure if this is the desired semantics, but it's what we

// TODO: Once it's just Fiber we can move this to node._wrapperState

// TODO: Only do this for the relevant Safaris maybe?

// TODO: Only ignore them on controlled tags.

// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we

// TODO: Pass `current` as argument

// TODO: Possibly defer this until the commit phase where all the events

// TODO: Probably should inline this back

// TODO: Probably should refactor `beginWork` to split the bailout

// TODO: Reconsider this. The counter-argument is that the partial work

// TODO: Remove ConcurrentMode by reading from the root tag instead

// TODO: Remove Update flag from before mutation phase by re-landing Visibility

// TODO: Remove `callback` when we delete legacy mode.

// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We

// TODO: Remove support for `selected` in <option>.

// TODO: Remove this dead flag

// TODO: Remove this function which also includes comment nodes.

// TODO: Replace with flushSync

// TODO: Restore state in the microtask, after the discrete updates flush,

// TODO: Restructure so we never read values from the instance.

// TODO: Reuse reappearLayoutEffects traversal here?

// TODO: Second argument used to be an optional `calculateChangedBits`

// TODO: Should not remove render lanes that were pinged during this render

// TODO: Should we use domElement.firstChild.nodeValue to compare?

// TODO: Special case idle priority?

// TODO: Split the update API as separate for the props vs. children.

// TODO: Temporary until we confirm this warning is not fired.

// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So

// TODO: This assumes that we're about to evaluate the component and process

// TODO: This breaks on empty slots like null children. That's

// TODO: This cast may not be sound for SVG, MathML or custom elements.

// TODO: This function is only called on host components. I don't think all of

// TODO: This function is supposed to be non-recursive.

// TODO: This function shares a lot of logic with findInstanceBlockingEvent.

// TODO: This gets called every time we yield. We can optimize by storing

// TODO: This gets logged by onRecoverableError, too, so we should be

// TODO: This is left over from the effect list implementation, where we had

// TODO: This is part of the `componentDidCatch` implementation. Its purpose

// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.

// TODO: This needs to run whenever there's an insertion or update

// TODO: This no longer makes any sense. We already wrap the mutation and

// TODO: This prevents the assignment of defaultValue to regular

// TODO: This will read the priority if it's dispatched by the React

// TODO: This will still suspend a synchronous tree if anything

// TODO: Type this specific to this type of component.

// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning

// TODO: Update these during the whole mutation phase, not just during

// TODO: Upgrade this definition once we're on a newer version of Flow that

// TODO: Use a static flag to skip trees that don't have unmount effects

// TODO: Use symbols?

// TODO: Use the unified fiber stack module instead of this local one?

// TODO: Warn if _enabled is false.

// TODO: Warn if there is more than a single textNode as a child.

// TODO: Warn in a future release.

// TODO: Warn in strict mode if getDerivedStateFromError is

// TODO: Warn, we didn't find the end comment boundary.

// TODO: Warn.

// TODO: We can move this to the passive phase once we add a pre-commit

// TODO: We can optimize this by not scheduling the callback earlier. Since we

// TODO: We can probably just avoid popping it instead and only

// TODO: We could fast path by just rendering the tail now.

// TODO: We have several of these arguments that are conceptually part of the

// TODO: We only check `didTimeout` defensively, to account for a Scheduler

// TODO: We really only need to unsuspend only lanes that are in the

// TODO: We should probably always mark the root as suspended immediately

// TODO: When we delete legacy mode, we should make this error argument

// TODO: add a more generic warning for invalid values.

// TODO: can we stop exporting these?

// TODO: figure out the API for cross-renderer implementation.

// TODO: findDOMNode doesn't rely on this any more but isMounted does

// TODO: ideally, we'd eventually add all events from

// TODO: if it was but can no longer be simple,

// TODO: pass ReactDOM portal implementation as third argument

// TODO: popHydrationState

// TODO: remove top-level side effect.

// TODO: revisit this when we implement resuming.

// TODO: throw or warn if we couldn't hydrate?

// TODO: we should remove the concept of a "SimpleEventPlugin".

// TODO: why is this nullable in the types but we read from it?

// Tab or newline are defined as \r\n\t:

// Tag the fiber with an update effect. This turns a Placement into

// Test for A's keys different from B.

// Tests whether the next lane is equal or lower priority than the wip

// Text Instances don't have children so there's nothing to hydrate.

// Text nodes don't have keys. If the previous node is implicitly keyed

// Thank's IE8 for his funny defineProperty

// That happens in the completeWork phase without going back to beginWork.

// That is depending on if we want nested subtrees (layers) to bubble

// That way we can keep the current update and future updates separate.

// That's probably okay; we don't support it just as we don't support

// That's why this function is separate from pushTreeId — it's called during

// The ._invoke method unifies the implementations of the .next,

// The ChangeEventPlugin registers a "propertychange" event for

// The Offscreen tree is hidden. Skip over its layout effects.

// The Suspense Context is split into two parts. The lower bits is

// The Symbol used to tag the ReactElement-like types.

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol

// The `if` statement here prevents auto-disabling of the safe

// The `start` method never changes.

// The `stateNode` is cyclical because on host nodes it points to the host

// The actual logic for this is spread out in different places.

// The actual meaning of the value depends on the users' keyboard layout

// The algorithm for assigning an update to a lane should be stable for all

// The alternative is to track the namespace in a few places which is convoluted.

// The assumption is that this is usually faster.

// The attribute name is case-sensitive in SVG so we can't just use

// The below logic attempts to work out if we need to change

// The boundary fiber (a Suspense component or SuspenseList component)

// The callback errored, but the error event never fired.

// The callback is an async function (i.e. returned a promise). Wait

// The callback is not an async function. Exit the current scope

// The callback threw an error.

// The cases in this outer switch modify the stack before they traverse

// The coercion safety check is performed in getToStringValue().

// The commit phase is broken into several sub-phases. We do a separate pass

// The context might have changed so we need to recalculate it.

// The context value changed. Search for matching consumers and schedule

// The context.catch method must only be called with a location

// The current composition is stored statically and must not be

// The current task was canceled. Exit. We don't need to call

// The current, flushed, state of this fiber is the alternate. Ideally

// The data might resolve before we have a chance to commit the fallback. Or,

// The default reveal order is the same as not having

// The dehydrated completion pass expects this flag to be there

// The delegate iterator is finished, so forget it and continue with

// The display name for this tags come from the user-provided type:

// The effect flag should be checked *after* we refine the type of fiber,

// The effect list of the backwards tail will have been added

// The effects are no longer valid.

// The enter-key is technically both printable and non-printable and can

// The error is fatal. Since the silencing might have

// The error is passed in as an argument to enforce that every caller provide

// The error is recoverable and was silenced.

// The error will be caught by the nearest suspense boundary.

// The errors from the failed first attempt have been recovered. Add

// The errors from the second attempt should be queued after the errors

// The existing first child is not a text node so we need to create one

// The fallback fiber was added as a deletion during the first pass.

// The first pass splits the children fibers into two sets. A head and tail.

// The first phase a "before mutation" phase. We use this phase to read the

// The inner component shouldn't inherit this display name in most cases,

// The inner type can have defaults too

// The instance needs access to the fiber so that it can schedule updates

// The last rebase update that is NOT part of the base state.

// The logic below for Context differs depending on PROD or DEV mode. In

// The main thread has been blocked for a non-negligible amount of time. We

// The module cache

// The most common types that will cause this exception are `Symbol` instances

// The new fiber is a work in progress, but if there exists a

// The next one that isn't the same should be our match though.

// The only remaining work is Idle.

// The opaque type returned by the host config is internally a lane, so we can

// The other host nodes also point back to fibers, so we should detach that

// The outermost shell has not hydrated yet. Start hydrating.

// The parent is larger. Swap positions.

// The parent is smaller. Exit.

// The pending lanes were cleared at the beginning of beginWork. We're

// The pending queue is circular. Disconnect the pointer between first

// The primary child fragment does not have pending work marked

// The primary children do not have pending work with sufficient

// The primary children have pending work. Use the normal path

// The props are shallowly equal. Reuse the previous props object, like we

// The props argument to `createFiberFromOffscreen` is `any` typed, so we use

// The props argument to `createWorkInProgress` is `any` typed, so we use this

// The purpose of this branch is to be super aggressive so we can measure

// The queue doesn't persist past this render pass.

// The queue is currently empty, which means we can eagerly compute the

// The queue of discrete events to be replayed.

// The react-debug-hooks package injects its own implementation

// The render completed.

// The render is suspended, it hasn't timed out, and there's no

// The render unwound without completing the tree. This happens in special

// The require function

// The resolved type is set if we know what the final type will be. I.e. it's not lazy.

// The rest are treated as attributes with special cases.

// The rest of this function is a fork of `updateClassComponent`

// The result can be nullish if a mock or a custom function is used.

// The return pointer of A and the return pointer of B point to different

// The return pointers point to the same fiber. We'll have to use the

// The return_targetInst field above is conceptually part of the return value.

// The root already suspended with a delay, which means this render

// The root entry object (effectively a try statement without a catch

// The root previous suspended and scheduled a timeout to commit a fallback

// The same thing applies to Suspense boundaries.

// The selectionchange event also needs deduplication

// The source fiber did not complete.

// The source fiber did not complete. Mark it with Sync priority to

// The store changed. Check if the snapshot changed since the last time we

// The suspended lanes are no longer CPU-bound. Clear their expiration times.

// The target is a portal, but it's not the rootContainer we're looking for.

// The theory is that a person can't tell the difference between small differences in time.

// The time it took to render last row is greater than the remaining

// The trick we use is to cache the first of each of these inputs within an

// The validation flag is currently mutative. We put it on

// The wakeable resolved, so we no longer need to memoize, because it will

// The whole list is part of the tail.

// The work completed. Ready to commit.

// The work expired. Commit immediately.

// The work loop is an extremely hot path. Tell Closure not to inline it.

// The work-in-progress fiber. I've named it differently to distinguish it from

// The work-in-progress queue is the same as current. This happens when

// The work-in-progress tree is now the current tree. This must come after

// Then create a bitmask that selects only those bits.

// Then we can remove this special list.

// Theoretically, nothing in here should be necessary, because we already

// There are no base updates.

// There are working polyfills for <dialog>. Let people use it.

// There is no alternate. This is an unusual case. Currently, it only

// There might be multiple of these in the list but since we're

// There might be nested nodes so we need to keep track of how

// There was an error during render that wasn't captured by a suspense

// There were errors during this render, but recovered from them without

// There were render phase updates. These are only valid for this render

// There's a few reasons for why we prefer setImmediate.

// There's additional work on this root.

// There's already a work-in-progress. Reuse it.

// There's no need to check for keys on text nodes since we don't have a

// There's no need to search deeper because for the purpose of giving

// There's no remaining sync work left.

// Therefore we need to go through the whole tail to find if

// Therefore we now have to render the fallback.

// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable

// These are "enumerated" HTML attributes that accept "true" and "false".

// These are "enumerated" SVG attributes that accept "true" and "false".

// These are HTML attributes that are "overloaded booleans": they behave like

// These are HTML attributes that must be numbers.

// These are HTML attributes that must be positive numbers.

// These are HTML boolean attributes.

// These are circular

// These are reserved SVG and MathML elements.

// These are reset during render to allow the DevTools commit hook a chance to read them,

// These are set right before calling the component.

// These are the few React props that we set as DOM properties

// These are tracked on the stack as we recursively traverse a

// These are updated in the passive phase

// These attribute exists both in HTML and SVG.

// These effects should only be committed when components are first mounted,

// These particular numbers are vague estimates. We expect to adjust them based on research.

// These props are reserved by React. They shouldn't be written to the DOM.

// These set relatedTarget to null because the replayed event will be treated as if we

// These tags are only valid with a few parents that have special child

// These two functions exist to still get child warnings in dev

// These values may change as we process the queue.

// These will be overridden during the parent's reconciliation

// They're redundant.

// Third, even if you set all that aside, Suspense is like error boundaries in

// This API will tag the children with the side-effect of the reconciliation

// This Fiber's initial properties will always be overwritten.

// This allows us to reset root when portals are popped.

// This approach works across all browsers, whereas `change` does not fire

// This avoids unnecessarily recomputing memoized values.

// This behavior is only a fallback. The flag only exists until we can roll

// This behavior/bug has something to do with Object.preventExtension().

// This boundary already captured during this render. Continue to the next

// This boundary did not suspend so it's now hydrated and unsuspended.

// This boundary has changed since the first render. This means that we are now unable to

// This boundary is in a permanent fallback state. In this case, we'll never

// This branch assumes the length of the base id is greater than 5; it won't

// This can be replaced with a WeakMap once they are implemented in

// This can end up rendering this component multiple passes.

// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.

// This can happen if you passed a class to function component, or non-function.

// This can happen when we abort work.

// This can't be a comment node since hydration doesn't work on comment nodes anyway.

// This case also applies to initial hydration.

// This check uses currentHook so that it works the same in DEV and prod bundles.

// This code is DEV-only so size is not a concern.

// This commit has passive effects. Stash a reference to them. But don't

// This component is still pending more data from the server, so we can't hydrate its

// This container might be used for a portal.

// This could've been a dehydrated suspense component.

// This dispatcher does that.

// This dispatcher handles an edge case where a component is updating,

// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,

// This element was passed in a valid location.

// This enables DevTools to start capturing timing at any point–

// This enables us to pop only Fibers that provide unique contexts.

// This ensures that the version used for server rendering matches the one

// This entry need to be wrapped in an IIFE because it need to be in strict mode.

// This environment has a native %IteratorPrototype%; use it instead

// This extracts the first frame from the sample that isn't also in the control.

// This fiber did not complete because something threw. Pop values off

// This fiber does not have any pending work. Bailout without entering

// This fiber doesn't have work, but its subtree does. Clone the child

// This first principle is that if we're going to suspend when we complete

// This function detects when a Suspense boundary goes from visible to hidden.

// This function is fork of reconcileChildren. It's used in cases where we

// This function is only called if that check has already passed.

// This function is used both for updates and for re-renders triggered by a

// This function is used for the experimental timeline (react-devtools-timeline)

// This gets reset before we yield back to the browser.

// This gives DevTools a way to feature detect that isn't tied to version number

// This happens if `finalizeInitialChildren` returns `true` (which it

// This has now been refined to a suspense node.

// This has now been refined to a text node.

// This has now been refined to an element node.

// This has the downside of resetting values for different priority renders,

// This hook is normally a no-op.

// This is a bit more complicated than other context-like modules in Fiber

// This is a breaking change that can wait until React 18.

// This is a client-only boundary. Since we won't get any content from the server

// This is a constructor function, rather than a POJO constructor, still

// This is a consumer

// This is a delayed task.

// This is a exponential search for each boundary that commits. I think it's

// This is a fork of `requestUpdateLane` designed specifically for Suspense

// This is a fork of runWithPriority, inlined for performance.

// This is a hydration root whose shell has not yet hydrated. We should

// This is a known bug.

// This is a lazy pooled frozen object, so we need to initialize.

// This is a list of all SVG attributes that need special casing, namespacing,

// This is a mapping from React prop names to the attribute names.

// This is a move.

// This is a new mount. Change the tag so it's not mistaken for a

// This is a polyfill for %IteratorPrototype% for environments that

// This is a re-render. Apply the new render phase updates to the previous

// This is a regular error, not a Suspense wakeable.

// This is a render phase update. Stash it in a lazily-created map of

// This is a render phase update. These are not officially supported. The

// This is a rerender during a mount.

// This is a separate check from includesBlockingLane because a lane can

// This is a special case that only exists for legacy mode.

// This is a special case. If any listener updates we need to ensure

// This is a sync render, so we should have finished the whole tree.

// This is a sync/discrete update. We treat this case like an error

// This is a transition, so we should exit without committing a

// This is a wakeable. The component suspended.

// This is also our approach for IE handling, for the reason above.

// This is always exactly one child

// This is always non-null on a ClassComponent or HostRoot

// This is an array for better minification.

// This is an insertion or in-progress hydration. The nearest possible

// This is an insertion.

// This is an unsafe render phase update. Add directly to the update

// This is an update.

// This is an urgent update. If the value has changed, keep using the

// This is because we only process these plugins

// This is because we only process this plugin

// This is called right after we reconcile an array (or iterator) of child

// This is called right before React yields execution, to ensure `readContext`

// This is done to prevent sibling component effects from interfering with each other,

// This is exported in FB builds for use by legacy FB layer infra.

// This is going to find the last row among these children that is already

// This is guaranteed to yield a script element.

// This is handy for testing error boundaries without noise.

// This is imported by the event replaying implementation in React DOM. It's

// This is in postMount because we need access to the DOM node, which is not

// This is inlined manually because closure doesn't do it for us.

// This is intentionally a factory so that we have different returned constructors.

// This is intentionally an invariant that gets caught. It's the same

// This is intentionally passing this fiber as the parent

// This is intentionally written as a list of all properties.

// This is more aggressive than ideal, and the long term goal is to only

// This is not a sync update. Suspend. Since we're not activating a

// This is not a transition, but we did trigger an avoided state.

// This is not an urgent update, so we can use the latest value regardless

// This is not replayable so we'll invoke it but without a target,

// This is only necessary when a select in "single selection mode".

// This is only used by createEventHandle when the

// This is reset by checkDidRenderIdHook

// This is simpler for the single child case. We only need to do a

// This is so gross but it's at least non-critical and can be removed if

// This is the basic functionality of the event system. All

// This is the beginning of the main content.

// This is the entry point for every concurrent task, i.e. anything that

// This is the entry point for synchronous tasks that don't go

// This is the first attempt.

// This is the first dependency for this component. Create a new list.

// This is the first hook in the list

// This is the first hook in the list.

// This is the first render pass. Attempt to hydrate.

// This is the first update since React yielded. Compute a new start time.

// This is the first update. Create a circular list.

// This is the outermost `act` scope. Initialize the queue. The reconciler

// This is the root of a reappearing boundary. Turn its layout effects

// This is the rootContainer we're looking for and we found it as

// This is the same implementation as reconcileChildrenArray(),

// This is the second render pass. We already attempted to hydrated, but

// This is the second render. The surrounding visible content has already

// This is used by DevTools to force a boundary to error.

// This is used by DevTools to force a boundary to suspend.

// This is used to create an alternate fiber to do work on.

// This is why we ensure that non React root containers have inline onclick

// This isn't a real property on the hook, but it can be set to opt out

// This isn't directly used but is handy for debugging internals:

// This isn't reachable because onRecoverableError isn't called in the

// This kind of inner function is not used elsewhere so the side effect is okay.

// This lane expired

// This marks a Suspense boundary so that when we're unwinding the stack,

// This matches the property of native CompositionEventInterface.

// This may be because it's a Context (rather than a Consumer).

// This may be unset if the props are determined to be equal later (memo).

// This may change in the future with e.g. nested hooks.

// This may have been an insertion or a hydration.

// This may trigger infinite loops if componentWillReceiveProps calls setState.

// This means both of them need to be registered to preserve state.

// This means that if a lane is entangled during an interleaved event while

// This message intentionally doesn't mention ForwardRef or MemoComponent

// This method must not throw, or React internal state will get messed up.

// This might have been modified.

// This might throw either because it's missing or throws. If so, we treat it

// This module is forked in different environments.

// This module only exists as an ESM wrapper around the external CommonJS

// This module should not be running in strict mode, so the above

// This needs to include all possible module reference object

// This node may have been reused from a previous render, so we can't

// This phase is only used for beforeActiveInstanceBlur.

// This prevents sibling component effects from interfering with each other,

// This prevents time from endlessly accumulating in new commits.

// This prevents:

// This render only included retries, no updates. Throttle committing

// This render triggered passive effects: release the root cache pool

// This resets the Fiber to what createFiber or createWorkInProgress would

// This returns the highest priority pending lanes regardless of whether they

// This should be called immediately after every renderWithHooks call.

// This should be fine because the only two other things that contribute to

// This should never happen. (Would happen if the anchor/focus nodes aren't

// This should only be reachable if we're suspended

// This should only happen during a concurrent render, not a discrete or

// This should throw.

// This shouldn't be reachable, but as a fallback, return the entire bitmask.

// This shouldn't happen, something went wrong but to avoid blocking

// This simplifies the code for getHostSibling and deleting nodes,

// This tag allow us to uniquely identify this as a React Portal

// This tag allows us to uniquely identify this as a React Element

// This tag is not present in non Electron environments such as JSDom which

// This target container was successfully dispatched. Try the next.

// This tree has been unmounted already. Dispatch without a target.

// This update does have sufficient priority.

// This update is going to be committed so we never want uncommit

// This update originated outside React. Ask the host environment for an

// This update was dispatched during the render phase. This is a mistake

// This warning would fire if you read context inside a Hook like useMemo.

// This will add the old fiber to the deletion list

// This will be the props with resolved defaultProps,

// This will restart the begin phase with a new fiber.

// This will throw if radio buttons rendered by different copies of React

// This won't trigger the performance cliff mentioned above,

// This would be a good time to rethrow if any of the event handlers threw.

// This wrapper function exists because I expect to clone the code in each path

// This wrapper function gets inlined. Only exists so to communicate that it

// Thrash, waste and sodomy: IE GC bug

// Throw out any hooks that were used.

// Timer fired. Transfer to the task queue.

// Timer was cancelled.

// Times out immediately

// To avoid creating an additional object, we just hang the .value

// To avoid side effects (such as losing text selection), only set value if changed

// To do this, we're going to go through the reconcile algorithm twice. In

// To figure out which ancestor instance we should use, we traverse

// To find which value is throwing, check the browser or debugger console.

// To fix the problem, coerce this object or symbol value to a string before

// To make comparing ReactElements easier for testing purposes, we make

// To preserve the expected "Pause on exceptions" behavior, we don't use a

// To preserve the preexisting retry behavior of error boundaries,

// To use getAttributeNS we need the local name which we don't have

// To work around this, initialize the fields below with doubles.

// Tor Browser bug: Math.asinh(0) -> -0

// Tor Browser bug: Math.atanh(-0) -> 0

// Touch keyboard of Windows.  In such a case, the `char` property

// Track the context and the Fiber that provided it.

// Track the current IME composition status, if any.

// Track the current state on the Offscreen instance so we can

// Track the input node that has focus.

// Track whether we've ever handled a keypress on the space key.

// Tracks components we have already warned about.

// Transfer the interleaved updates onto the main queue. Each queue has a

// Transfer time spent rendering these children so we don't lose it

// Transition to the next state.

// Translated: If C is entangled with A, then entangling A with B also

// Traverse down.

// Traverse the Offscreen subtree with the current Offscreen as the root.

// Trust the developer to only use possibleRegistrationNames in true

// Try to search down until we find one.

// Try to unify them. It's a bit tricky since it would require two return

// Try/catch helper to minimize deoptimizations. Returns a completion

// Turn on layout effects in a tree that previously disappeared.

// Two elements created in two different places should be considered

// Typically this will be the root most one. However, stack frames may be

// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'

// Unfortunately it makes React unusably slow for some applications.

// Unknown attributes should have lowercase casing since that's how they

// Unless this is the first id at this level, append a number at the end

// Unless we're rendering a blocking lane, schedule a consistency check.

// Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.

// Unlike the class check below, it's not enforced in production for perf.

// Unmount

// Unmount should not be batched.

// Unmount the root by rendering null.

// Unsafe lifecycles should not be invoked for components using the new APIs.

// Unset styles on `lastProp` but not on `nextProp`.

// Unwind the failed stack frame

// Update

// Update checked *before* name.

// Update render duration assuming we didn't error.

// Update styles that changed since `lastProp`.

// Update the child lanes of all the ancestors, including the alternates.

// Update the childLanes even though we're most likely already rendering

// Update the existing instance's state, props, and context pointers even

// Update the fiber if the keys match, otherwise return null.

// Update the first and last pending times on this root. The new first

// Update the next thing we're working on in case something throws.

// Update the props handle so that we know which props are the ones with

// Update the remaining priority in the queue.

// Update the return pointer so the tree is consistent. This is a code

// Update the source fiber's lanes

// Update the wrapper around inputs *after* updating props. This has to

// Updates originating inside certain React methods, like flushSync, have

// Use a captial R prefix for server-generated ids.

// Use the `click` event to detect changes to checkbox and radio inputs.

// Use the latest known implementation.

// Use this function to schedule a task for a root. There's only one task per

// Use this to detect multiple renderers using the same context

// Use this to track whether the error event is ever called.

// Used by SimpleEventPlugin:

// Used by persistent updates

// Used by polyfills:

// Used by the renderer to print a warning if certain APIs are called from

// Used during the commit phase to track the state of the Offscreen component stack.

// Used for hot reloading:

// Used for stashing WIP properties to replay failed work in DEV.

// Used to reproduce behavior of `batchedUpdates` in legacy mode.

// Used to reproduce behavior of `batchedUpdates` in legacy mode. Only

// Used to reuse a Fiber for a second pass.

// Used to track how many concurrent renderers this context currently

// User interactions should expire slightly more quickly.

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an

// Using console['error'] to evade Babel and ESLint

// Using console['warn'] to evade Babel and ESLint

// Usually the current owner is the offender, but if it accepts children as a

// V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.

// V8 bug

// V8 near Chromium 38 has a problem with very small numbers

// V8 throws on boxed symbols

// V8 ~ Android 4.3-

// V8 ~ Chromium 42- fails only with 5+ elements

// Validate that the properties correspond to their expected values.

// Verify deps, but only on mount to avoid extra checks.

// Visit this fiber.

// Walk in lockstep until we find a match.

// Walk the parent path to the root and update the child lanes.

// Warn about these lifecycles if they are present.

// Warn about using Maps as children

// Warn when a known attribute is a bad type

// Warn when passing the strings 'false' or 'true' into a boolean prop

// Warning, this opts-out of checking the function body.

// We already have an alternate.

// We already have an existing node so let's just update it and delete

// We also skip portals because they are not part of this host tree.

// We also use this flag to connect/disconnect the effects, but the same

// We always throw the original error in case the second render pass is not idempotent.

// We aren't actually adding an update to the queue,

// We assume pendingProps, index, key, ref, return are still untouched to

// We assume that prepareToHydrateHostTextInstance is called in a context where the

// We can accumulate the flags, and the targetContainers, and

// We can always overwrite an existing timestamp because we prefer the most

// We can assume the previous dispatcher is always this one, since we set it

// We can reset these now that they are finished.

// We can reuse the existing object from previous renders.

// We can suspend and wait for more data to arrive.

// We can use any RetryLane even if it's the one currently rendering

// We can't disconnect `alternate` on nodes that haven't been deleted

// We can't rely on the event system being injected on the server.

// We check for window.hasOwnProperty('event') to prevent the

// We construct a different control for this case to include any extra

// We could also eagerly patch the method.

// We could check it early to avoid scheduling an unnecessary callback.

// We could have created a separate document here to avoid

// We could move it there, but we'd still need this for lazy code path.

// We could update instance props and state here,

// We could've passed this the first time

// We create tags in the namespace of their parent container, except HTML

// We currently set sibling to null and index to 0 here because it is easy

// We didn't find a boundary that could handle this type of exception. Start

// We disable time-slicing in some cases: if the work has been CPU-bound

// We do an initial pass to gather component names

// We don't currently have a way to increase the priority of

// We don't do anything in this mode.

// We don't do this if the incoming update is idle, because we never process

// We don't have strong guarantees that the props object is referentially

// We don't have to traverse to the children of the list since

// We don't include the original error message and JS stack because the browser

// We don't mind this list too much because we expect it to never grow.

// We don't need to re-check StrictEffectsMode here.

// We don't process these events unless we are in the

// We don't support rendering Generators because it's a mutation.

// We don't support running callbacks in the middle of render

// We don't want exception behavior to differ between dev and prod.

// We eagerly listen to this even though we haven't committed yet.

// We encode the id in multiple steps: first the base id, then the

// We expect at least one stack frame to be shared.

// We explicitly want to coerce to number here if possible.

// We first render the head. If anything is in fallback state, we do another

// We found a suspense instance. That means that we haven't

// We got a match.

// We had an attribute but shouldn't have had one, so read it

// We handle selectionchange separately because it

// We have a match. This only drills down to the closest host components.

// We have a queue to process.

// We have already passed our CPU deadline but we still have rows

// We have an acceptable loading state. We need to figure out if we

// We have new updates that haven't been processed yet.

// We have no life-cycles associated with portals.

// We have now passed our CPU deadline and we'll just give up further

// We have successfully injected, so now it is safe to set up hooks.

// We immediately remove the callback from event listeners so that

// We initialize the default updater but the real one gets injected by the

// We intentionally don't use spread (or .apply) directly because it

// We intentionally reset, rather than copy, actualDuration & actualStartTime.

// We just rendered the head.

// We know that this component will suspend again because if it has

// We listen to these events in case to ensure emulated bubble

// We listen to this event in case to ensure emulated bubble

// We matched the next one, we'll now assume that the first one was

// We matched the slot, but we didn't reuse the existing fiber, so we

// We may still have similar intermediate frames from the construct call.

// We might bail out of the loop before finding any but that

// We might be inside a hydration state the first time we're picking up this

// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration

// We need to check again if something threw

// We need to clear only if we didn't queue because

// We need to do this after the Hot Reloading check above,

// We need to pass this through as an argument to commitRoot

// We need to temporarily unset name to avoid disrupting radio button groups.

// We need update the tracked value on the named cousin since the value

// We no longer need to track the active instance fiber

// We now have a consistent tree. Because this is a sync render, we

// We now have a consistent tree. The next step is either to commit it,

// We only attach ping listeners in concurrent mode. Legacy Suspense always

// We only do this deeper than head and body since they tend to have random

// We only have the top Fiber that was created but we need recurse down its

// We only have the top Fiber that was deleted but we need to recurse down its

// We only have the top Fiber that was inserted but we need to recurse down its

// We only need to do this in concurrent mode. Legacy Suspense always

// We only need to remove the topmost host child in each branch. But then we

// We only use a Fiber to ensure the same hidden class so DEV isn't slow.

// We only use it in places that are currently more relaxed.

// We only use this for id generation during hydration, which is why the

// We only want to warn if we're sure it's a new React.

// We overflowed the bitwise-safe range. Fall back to slower algorithm.

// We perform this translation at the end of the event loop so that we

// We pick a train model where the next boundary commits at a consistent schedule.

// We prefer MessageChannel because of the 4ms setTimeout clamping.

// We push the context as early as possible to ensure stack integrity.

// We record this information as an expando on the error.

// We scheduled a timeout but it's no longer needed. Cancel it.

// We should never be hydrating at this point because it is the first pass,

// We should never have an alternate for any mounting node. So the only

// We should never render the children of a dehydrated boundary until we

// We should not delegate these events to the container, but rather

// We should only fallback here in non-browser environments.

// We should only process this nativeEvent if we are processing

// We should only use this function for:

// We should prefer to render the fallback of at the last

// We show the whole stack but dedupe on the top component's name because

// We special case a direct text child of a host node. This is a common

// We still have tail rows to render.

// We suspended during the head. We want to show at least one

// We tried to use Object.assign() instead but this is called in

// We unwound to the root without completing it. Exit.

// We use a double buffering pooling technique because we know that we'll

// We use a throwing setter instead of frozen or non-writable props

// We use the highest priority lane to represent the priority of the callback.

// We use the prefix to ensure our stacks line up with native stack frames.

// We use these fields to store the result.

// We use this as a heuristic. It's based on intuition and not data so it

// We want to ensure that a "busy" state doesn't get force committed. We want to

// We want to match the production code behavior (which will use HooksDispatcherOnMount),

// We warn in this case but don't throw. We expect the element creation to

// We warn when you define propTypes on lazy()

// We weren't previously hidden, and we still aren't, so there's nothing

// We will have dropped the effect list which contains the

// We will invalidate the child context in finishClassComponent() right after rendering.

// We will still patch up in this case but not fire the warning.

// We won't do this if we're hydrating server-rendered content, because if

// We'd like to remove this but it's not clear if this is safe.

// We'll add them to the base queue.

// We'll check if this is a container root that could include

// We'll continue hydrating the rest at offscreen priority since we'll already

// We'll get a different iterator later for the main pass.

// We'll use it to determine whether we need to initialize legacy refs.

// We're at the root.

// We're back to the root of this subtree. Exit.

// We're blocked on hydrating this boundary.

// We're deeper than the current hydration context, inside an inserted

// We're done.

// We're going from hidden -> visible.

// We're going to commit this fiber even though it didn't complete.

// We're going to find the first row that has existing content.

// We're going to render them separately later.

// We're going to search forward into the tree until we find a sibling host

// We're hidden, and we're not rendering at Offscreen. We will bail out

// We're in a test because Scheduler.unstable_yieldValue only exists

// We're not blocked on anything.

// We're not inside React, so we may be in the middle of a browser event.

// We're now not suspended nor dehydrated.

// We're running in the default, "independent" mode.

// We're still blocked.

// We're still blocked. Try again later.

// We're unblocked.

// We've determined that A is the current branch.

// We've determined that B is the current branch.

// We've exited the outermost act scope. Recursively flush the

// We've reached the end of the new children. We can delete the rest.

// We've reached the root.

// We've unwound all the way to the root.

// WebKit Array.of isn't generic

// WebKit converts symbol values to JSON as null

// Webkit offers a very useful `textInput` event that can be used to

// When a checked radio tries to change name, browser makes another radio's checked false.

// When a fiber is cloned, its actualDuration is reset to 0. This value will

// When a yielded Promise is resolved, its final value becomes

// When adding attributes to the HTML or SVG allowed attribute list, be sure to

// When adding attributes to this list, be sure to also add them to

// When adding new symbols to this file,

// When blurring, set the value attribute for number inputs

// When legacyFBSupport is enabled, it's for when we

// When suspending, we should always exclude lanes that were pinged or (more

// When syncing the checked attribute, both the checked property and

// When syncing the checked attribute, it only changes when it needs

// When syncing the value attribute, the value comes from a cascade of

// When syncing the value attribute, the value property should use

// When the wakeable resolves, we'll attempt to render the boundary

// When updates are sync by default, we entangle continuous priority updates

// When we go into a portal, it becomes the parent to remove from.

// When we made it larger, a product metric in www regressed, suggesting

// When we try rendering again, we should not reuse the current fiber,

// When work is done, it should bubble to the parent's actualDuration. If

// Whenever getSnapshot or subscribe changes, we need to check in the

// Whether or not it would crash later, we want to show a good message in DEV first.

// Which might result in "SecurityError" DOM Exception and it is compatible to Safari.

// While a Suspense Instance does have children, we won't step into

// Widget Attributes

// Will result in a null access error if accessed outside render phase. We

// Within the body of any async function, `await x` is transformed to

// Without some nodes in the tree having empty base times.

// Without this first invariant, passing a non-DOM-component triggers the next

// Work in progress (ex: onload events in incremental mode).

// Work in progress.

// Works with __proto__ only. Old v8 can't work with null proto objects.

// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't

// Yielding to the browser will give it a chance to paint, so we can

// \d\d?

// `AdvanceStringIndex` abstract operation

// `RegExp.prototype[@@match]` method

// `RegExp.prototype[@@replace]` method

// `RegExp.prototype[@@search]` method

// `RegExp.prototype[@@split]` method

// `RegExpExec` abstract operation

// `Scheduler.runWithPriority`, which accepts a function. But now we track the

// `String.prototype.match` method

// `String.prototype.replace` method

// `String.prototype.search` method

// `String.prototype.split` method

// `act` calls can be nested, so we track the depth. This represents the

// `baseState` can always be the last state because the root doesn't

// `baseState` is true when the current value is different from the rendered

// `charCode` is the result of a KeyPress event and represents the value of

// `componentDidCatch`. The mechanism is known to be flawed because `setState`

// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render

// `ensureRootIsScheduled` because the check above implies either that

// `expectedStyle` to a temporary DOM node to read its `style` attribute

// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which

// `form.getElementsByName`, but that will only return direct children

// `getDerivedStateFromError` instead. However, it could be improved by

// `hasMoreWork` will remain true, and we'll continue the work loop.

// `hasOwn.call(value, "__await")` to determine if the yielded value is

// `keyCode` is the result of a KeyDown/Up event and represents the value of

// `nativeEventTarget` is probably a window object.

// `omittedCloseTags` except that `menuitem` should still have its closing tag.

// `pending` field and an `interleaved` field. When they are not null, they

// `preventDefault()` in window `error` handler.

// `queue.lanes` is used for entangling transitions. We can set it back to

// `subtreeLanes` of the updated fiber, or the update lanes of the return

// `toString`ed by IE8/9.

// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this

// `which` is an alias for either `keyCode` or `charCode` depending on the

// `ws` module bug, temporarily remove validation length for Uint8Array

// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test

// a "grops" property.

// a PlacementAndUpdate.

// a Suspense boundary's inner Offscreen wrapper fiber. This happens

// a batch. This is intentionally inside scheduleUpdateOnFiber instead of

// a better way to communicate whether this was a miss or null,

// a boundary.

// a child. Since we want to append the update only to the work-in

// a compiler or we can do it manually. Helpers that don't need this branching

// a custom message, or explicitly opt out (currently the only path that opts

// a deletion.

// a fallback, then we should always suspend/restart. Transitions apply

// a global event handler. But because the error happens in a different

// a host component or host text.

// a nested suspense boundary within it. So we can use this as a fast

// a new mount, even though an empty version of it already committed.

// a new one. We need to return the patched regex when creating the new one.

// a parent of the Portal. That means we can ignore it because the

// a parent to this boundary was displayed. However, since we currently don't have

// a passive effect, which is when we process the transitions

// a property called "_context", which also gives us the ability to check

// a protocol to transfer that time, we'll just estimate it by using the current

// a push/pop misalignment.

// a re-render, and the error will be rethrown during render.

// a regular update because the initial render must match was was rendered

// a root other than sync.

// a root, then we should also restart if we get an update or ping that

// a stack.

// a state hook field instead of creating a new one.

// a superset of the actually pending lanes. In some cases we may entangle

// able to remove it.

// about to bail out, but there might be other lanes that weren't

// accidentally pass it on to the delegate.

// across different ways of memoizing a component. For example, React.memo

// active and not passive.

// actual time across multiple render passes.

// actually inside the passed-in node.)

// add "__proto__" for Object.getPrototypeOf polyfill

// add .keys, .values, .entries, [@@iterator]

// add [@@species], 23.1.2.2, 23.2.2.2

// add missing metadata

// add to index

// additional work on this root is scheduled.

// affect whether the props object is reused during a bailout.

// affecting the algorithms where its used. Here I'm using

// after each key entry. The selection changes after keydown and before

// after first render to prevent infinite render phase updates.

// after we rerender. This is used as a helper in special cases

// again ("retry").

// again. This is the same as context updating.

// aka when there is no current/alternate.

// all enumerable object keys, includes symbols

// all except special table nodes which cause bad parsing behavior anyway.

// all lifecycle effect tags.

// all object keys, includes non-enumerable and symbols

// all pending updates are included. If it still fails after the second

// all previous Promises have been resolved before calling invoke,

// allow <SVG> or <mATH>.

// allowlist; this is only for our internal use.

// almost identical to the logic used in the normal update path,

// already attempted and failed to hydrate at that level. Also check if we're

// already cloned. In legacy mode, the only case where this isn't true is

// already have an existing method we want to call, so there's no need

// already hydrated.

// already rendering that lane, which is rare but could happen.

// already started rendering.

// also add them to this module to ensure casing and incorrect name

// also ensures that the minifier will not anonymize the function.

// also have been non-React nodes. We need to answer which one.

// always receive the correct fiber here

// always synchronous.

// an effect to toggle the subtree's visibility. When we switch from

// an external backing store so that we can freeze the whole object.

// an immutable object with a single mutable value

// an implementation detail, like selective hydration.

// an isolated frame and process.

// ancestor components where the exception happened.

// and .done properties off the next function object itself. This

// and Temporal objects like `Temporal.Instant`. But any object that has a

// and a handler for that event throws. We should be resilient to most of

// and any newline or tab are filtered out as if they're not part of the URL.

// and apply the stashed updates on top of the work-in-progress hook.

// and both offsets 0, in which case we will have handled above.

// and creates false positives. To make this work in legacy mode, we'd

// and default updates, so they render in the same batch. The only reason

// and delete the existing ones.

// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240

// and don't track value will cause over reporting of changes,

// and eligible for a replay.

// and have the same names are omitted, just like in the HTML attribute filter.

// and https://github.com/facebook/react/issues/14239

// and isMounted is deprecated anyway so we should be able to kill this.

// and it is guaranteed to be the work-in-progress version.

// and it simplifies other profiler code (including DevTools).

// and last so that it's non-circular.

// and nobody should be using this in existing code.

// and prepare a fresh one. Otherwise we'll continue where we left off.

// and render it again without hydration.

// and replace it on the stack later when invalidating the context.

// and resume this tree later.

// and switch to a different tree. Like a try/catch block. So we have to track

// and the same name are rendered into the same form (same as #1939).

// and the second argument - flag - preferred type is a string

// and there for cut off earlier. So we should find the root most frame in

// and we won't require Trusted Type here.

// and with only the default shallow comparison, we upgrade it

// and won't include inputs that use the HTML5 `form=` attribute. Since

// another level, but there's still an inner boundary that would show a fallback,

// any context has changed, we need to treat is as if the input might have changed.

// any necessary setup in a predictable way. This predictability

// any references to cancelBubble throw "Member not found".  A

// any work remaining at all (which would also include stuff like Suspense

// anything before them are not considered for collapsing.

// anywhere in the tree. This effectively throttles progressive loading into a

// appears to fire in all of the remaining cases so we catch those and

// appropriate priority, based on the type of event.

// approximate the planned Fiber refactor. In that world, `setState` will be

// are a single conceptual unit. The legacy mode behavior where we

// are consolidated.

// are remaining.

// are shallowly equal, but there's a local state or context update in the

// are suspended.

// are the same, the old child is unmounted and a new child is created.

// argument that corresponds to a known catch block.

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

// aria-* attributes should be lowercase; suggest the lowercase version.

// around this limitation, we use an opaque type that can only be obtained by

// array based heap, only the first one.)

// as an error.

// as appropriate.

// as before. We can fast bail out.

// as having hydrated so events know that they're free to be invoked.

// as part of its normal complete phase. But when we switch from

// as still uninitialized and try again next time. Which is the same as what

// as the deepest instance.

// as the newProps. The updatePayload will contain the real change in

// assigning it a key.

// assignment should always work unless something is misconfigured. Just

// assignment step above.

// assume its return pointer is correct.

// assume that the child is current. This happens when we bailout on low

// assuming that after the first child we've already added everything.

// assuming we're in node, let's try to get node's

// async functions in terms of async generators, it is especially

// at offscreen priority.

// at the beginning of the render phase and there's no re-entrance.

// at the end of the current scope even when using the sync version

// at the next level instead of this one, because the child props

// attach a listener now. When it resolves ("pings"), we can decide whether to

// attached to each React Root and React Portal Root. Together,

// attempt to hydrate.

// attempt, we'll give up and commit the resulting tree.

// attempt. If so, add them to a queue so we can log them in the

// attempts to re-render the boundary in the primary (pre-timeout) state.

// attempts to render the main content and only render fallbacks.

// attribute are assigned at the same time using defaultChecked. This uses:

// attributeName

// attributeNamespace

// attributes on `select`s needs to be added before `option`s are inserted.

// available until after the component has mounted.

// avoid doing another reconciliation.

// avoids allocating another HostText fiber and traversing it.

// avoids inaccurate Profiler durations in the case of a

// back here again.

// back on.

// back to client side render.

// bailout. Most of the time, when people add non-React children to

// bails out of the update without touching the DOM.

// base state.

// based on es5-shim implementation, need to rework it

// batch. This enables them to be grouped later.

// batchedUpdates or flushSync.

// be core the to event system. This would potentially allow

// be empty).

// be fired.

// be necessary but unfortunately many code paths reads from the workInProgress

// be referenced by a node in the tree (HostRoot, Cache boundary etc)

// be retried at a hydration lane.

// be scheduled. Use a counter to prevent infinite loops.

// be showing the right content coming from the server, it is no rush.

// be successfully parsed from HTML, but will produce a mismatch

// be transferred to the pending queue.

// because a MemoComponent fiber does not have hooks or an update queue;

// because discrete renders are expected to produce a complete tree

// because hot reloading has different semantics than prod because

// because in an ideal world we would not emulate and use

// because in this case the "suspended" fiber is the inner

// because it's guaranteed to have already run when movementX

// because it's only used for profiling), but it's a refactor hazard.

// because that won't throw in a non-strict mode function.

// because the component may be used elsewhere.

// because the effect is also where times bubble to parent Profilers.

// because the fact that it's a separate type of work is an

// because the fiber tag is more specific. An exception is any flag related

// because the same Fiber may appear on the stack multiple times and for

// because there is no update we can add for useReducer hooks that won't trigger an error.

// because there's no ancestor that can handle it; the root is

// because these events do not consistently bubble in the DOM.

// because they're only guaranteed to be resolved here.

// because we assume its namespaced name is the same as our config.

// because we bailout on the primary tree completely and leave it in its old

// because we want to schedule this fiber as having work

// because workInProgressTransitions might have changed between

// because you think you might want to restart before committing. However,

// been accidental, we'll surface it anyway.

// been unsuspended it has committed as a resolved Suspense component.

// before the children effects hae fired.

// before the effects on this fiber have fired.

// before the next rerender (including event handlers attached to ancestor

// before the second keystroke). Other input methods (e.g., paste) seem to

// begin phase by the time we start processing the queue, so we've already

// behavior as without this statement except with a better message.

// being called "element".

// belong to the child set of A.return, and B must belong to the child

// bind

// bind timers to global for call from export context

// bits into a string of 4 characters, with 3 bits left over.

// blank-text buttons.

// bookkeeping for it. Not sure if we need to clear it when the listener is

// boolean, undefined, etc.

// booleans, but can also accept a string value.

// bother waiting until the root is complete.

// bottom->up. Top->down is faster in IE11.

// bound to a special "instance" object instead of a Fiber. The Instance

// boundaries that aren't associated with a Suspense tree. In anticipation

// boundary or suspense list.

// boundary with ShouldCapture and enter the unwind phase.

// boundary's children. This involves some custom reconciliation logic. Two

// boundary) already mounted but this is a new fiber.

// boundary.

// boundary. Do a second pass on the root to unmount the children.

// breaks IE9: https://github.com/facebook/react/issues/13610

// browsers for all cases.

// browsers typically do this as necessary, jsdom doesn't.

// browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

// browsers. It adds spaces and sorts the properties in some

// bug we're still investigating. Once the bug in Scheduler is fixed,

// but

// but I won't :)

// but ToNumber should return NaN if a string contains unavailable symbols

// but after we've already committed once.

// but as an intermediary step, we will use jsxDEV for everything except

// but at commit. Therefore we need to track insertions which the normal

// but for some reason `nativeSlice.call(result, 1, result.length)` (called in

// but instead we rely on them being set during last render.

// but it is attached to the document.

// but it triggers a bug in IE11 and Edge 14/15.

// but it's better then a hard failure

// but it's possible that we only have its inner render function in the map.

// but no stateful hooks have been used.

// but that sometimes behaves strangely in IE8. We could also try using

// but the normal suspense pass doesn't.

// but using the iterator instead.

// but we have a user-provided "displayName"

// but with the extra DEV validation to ensure hooks ordering hasn't changed.

// by a create function in another component during the same commit.

// by calls to these methods by a Babel plugin.

// by the native compositionend event may be incorrect. Japanese ideographic

// call invoke immediately, without waiting on a callback to fire,

// call something on iterator step with safe closing on error

// call the user-provided callback.

// callback again.

// calls are equivalent because they wrap the same Foo function.

// can be used for comparison.

// can track the nearest host component on the JS stack as we traverse the

// can wait until after paint.

// can't foresee right now.

// can't set metadata to uncaught frozen object

// cannot be called outside the render phase.

// capture values if possible.

// case. We won't handle it as a reified child. We will instead handle

// cases are invalid.

// cases where need to exit the current render without producing a

// catch any error that may otherwise arise. See

// caught by a nested boundary. If not, it should bubble through.

// causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

// chance to clean up.

// change existing entry

// changed.

// check if they're dehydrated ones or not.

// check on default Array iterator

// checking if remainingLanes includes Sync work, instead of whether there's

// checking whether we scheduled a subscription effect above.

// child fragment.

// children again, not the fallback.

// children and the parent.

// children are a linked list, an earlier sibling that's still alive

// children to find all the terminal nodes.

// clean-up function, and we track the deps correctly, we can call pushEffect

// client rendering, up to the nearest Suspense boundary.

// client side render instead.

// clone, or a work-in-progress hook from a previous render pass that we can

// cloned by comparing the child pointer.

// code we must have exited earlier.

// coerce it to a string using `'' + value`, an exception was thrown.

// coercion ESLint rule, so we must manually disable it below.

// collection id

// collection type

// commenting out one of the conditions below.

// commit phase if there was an interleaved mutation. In concurrent mode

// commit phase, once the entire tree has finished.

// commit phase.

// commit phase. Consider removing the type check.

// commit-phase we mark this as such.

// commitRoot never returns a continuation; it always finishes synchronously.

// commits fallbacks synchronously, so there are no pings.

// committed. If it's sync, we still want to yield so that it can be

// committed. Now we resume rendering the hidden tree.

// commonly used development environments.

// compatibility and should always be accompanied by a warning.

// complete phase (bubbleProperties).

// completed class component. For example, we should not call

// completed work in order to do it.

// completed, even though it's in an inconsistent state.

// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this

// component (SimpleMemoComponent) versus if you pass a different type

// component (i.e. when processing the update queue). But since since

// component's mount, ignore it for now (that is, treat it as if it was an

// componentWillUnmount if it is deleted.

// componentWillUnmount, but before the layout phase, so that the finished

// components don't work properly in conjunction with event bubbling because

// compositionevent, otherwise extract it at fallback events.

// concurrent tree, in an inconsistent state. We want to treat it like

// concurrentUpdatesByDefaultOverride,

// confirm that any newly rendered stores are consistent.

// consideration the leading 1 we use to mark the end of the sequence.

// consistency check. See the next comment.

// consistent train of commits. This also gives us an opportunity to restart to

// consistent tree or committing.

// constructor polyfill

// container with previous children. It's also safe to do for

// contains hooks.

// contains in native

// contains the DOM rendered by the server.

// content. We treat it as if this component suspended itself. It might seem as if

// context.dispatchException(context.arg) call above.

// context.method was "next", forget context.arg since it has been

// continue to propagate through the React fiber tree to find other

// convert -0 to +0

// correct subclassing with @@species support

// corresponding changes there.

// could alter all these plugins to work in such ways, but

// could split this into two separate traversals functions, where the second

// could unblock them. Clear the suspended lanes so that we can try rendering

// create collection constructor

// createDict = iframe.contentWindow.Object;

// cross-realm fallback

// ctrlKey && altKey is equivalent to AltGr, and is not a command.

// current iteration.

// current, that means that we reused the fiber. We need to delete

// currently renderings (a pattern that is accompanied by a warning).

// currently schedule the callback in multiple places, will wait until those

// cut off due to maximum stack limits. In this case, one maybe cut off

// data types for reserved props

// de-opt to client rendering should have an error message.

// dealt with the props. Context in components that specify

// decided not to enable it.

// deep we are and only break out when we're back on top.

// deeply they are nested. We should use a subtree flag to track whether a

// default updates do not support refresh transitions.

// default value provided by the browser. See: #12872

// default, slow path: scan the child sets of each parent alternate to see

// defaultValue property -- do we need this?

// define getter functions for harmony exports

// defined.

// definitely won't finish. Since we have a new update, let's mark it as

// delegate iterator, or by modifying context.method and context.arg,

// deleted subtree.

// deleting text, so we ignore its input events.

// deleting the children, track that it's already unmounted so that we

// deletion. We need to reconcile to delete the current child.

// deletions from hidden tree. In Concurrent Mode, it's much simpler,

// dependency list.

// destroy functions for all fibers are called before any create functions.

// difference in the experience. However, waiting for longer might mean that we can avoid

// different from the current state.

// different layout, where the child points to a dehydrated fragment, which

// different reasons. We have to keep popping until the work-in-progress is

// directly represent `beforeInput`. The IE `textinput` event is not as

// directly, without storing any additional state. For the same reason, we

// disabled with `removeAttribute`. We have special logic for handling this.

// discarding the dehydrated content and switching to a client render.

// disconnected the fiber from the tree. So even if something leaks this

// dispatch our fake event using `dispatchEvent`. Inside the handler, we

// dispatched event, so that the debugger will treat it as an uncaught

// dispatching them after the mount.

// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.

// do for gDSFP. I can't remember why.

// do in Concurrent Mode.

// do is to check its .name property.

// do not delay if we're inside an act() scope

// do the portal feature.

// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)

// document. Let's just use the local `querySelectorAll` to ensure we don't

// does happen.

// does to implement the `autoFocus` attribute on the client). But

// doesn't bubble and needs to be on the document.

// doesn't expect a non-string/function type and can throw confusing errors.

// doesn't fire when text is deleted, but conveniently, selectionchange

// doesn't give us keycodes, so we need to ignore it.

// doesn't matter since that means that the other boundaries that

// doesn't matter which bit is selected; you can pick any bit without

// doesn't, we manually listen for the events and so we have to enqueue and

// don't attempt to unmount the effects again.

// don't hoist over string (html) components

// don't natively support it.

// don't need to set a static flag, either.

// don't want this event dispatched twice through the event system.

// double values will cause Fibers to end up having separate shapes.

// during componentDidUpdate we pass the "current" props.

// during the hydration attempt are now recovered. We will log them in

// during the render phase instead.

// during the render phase.

// e.g. a destroy function in one component should never override a ref set

// earlier than the other. We assume that the sample is longer or the same

// early implementations not supports chaining

// effect even though we're bailing out, so that cWU/cDU are called.

// effect may have mutated the store.

// effect of all current children being unmounted; even if the type and key

// effect of interrupting the current render and switching to the update.

// effects again.

// elements (not just inputs). Now that ReactDOMInput assigns to the

// elements instead of directly on the input). Without this, controlled

// empty, we need to schedule the text content to be reset.

// emulating an uncaught JavaScript error.

// emulation (EnterLeave) or use state localized to that

// end up fixing it if the resolution was a concurrency bug.

// enqueue has not been called before, then it is important to

// enqueue the callback if one is provided).

// ensure that new initial loading states can commit as soon as possible.

// entangle it again, just to be sure.

// entangle when we should.

// entangled with *all* the given lanes.

// entangled with *any* of the given lanes, that lane is now transitively

// entanglement is usually "best effort": we'll try our best to render the

// entangles C with B.

// equal during updates where we can't bail out anyway — like if the props

// equal for testing purposes and therefore we hide it from enumeration.

// equivalent to this check.

// error See ReactErrorUtils for more information.

// error boundaries.

// error can be observed.

// erroring and the code that follows the `dispatchEvent` call below. If

// errors, it will trigger our global error handler.

// errors: https://github.com/facebook/create-react-app/issues/3482

// errs on the side of fewer warnings

// eslint-disable-line

// eslint-disable-line no-new

// eslint-disable-line no-script-url

// eslint-disable-line no-undef

// eslint-disable-line no-unused-vars

// eslint-disable-next-line

// eslint-disable-next-line max-statements

// eslint-disable-next-line no-fallthrough

// eslint-disable-next-line no-loop-func

// eslint-disable-next-line no-new-func

// eslint-disable-next-line no-prototype-builtins

// eslint-disable-next-line no-redeclare

// eslint-disable-next-line no-self-compare

// eslint-disable-next-line no-throw-literal

// eslint-disable-next-line no-undef

// eslint-disable-next-line no-unreachable

// eslint-disable-next-line no-unused-vars

// eslint-disable-next-line no-useless-call

// eslint-disable-next-line react-internal/no-production-logging

// eslint-disable-next-line react-internal/prod-error-codes

// eslint-disable-next-line react-internal/safe-string-coercion

// eslint-disable-next-line-no-fallthrough

// even listeners these nodes might be wired up to.

// even with the prod transform. This means that jsxDEV is purely

// event exists. So we wouldn't see it and dispatch it.

// event loop context, it does not interrupt the normal program flow.

// event on a non-React tree). We might also consider queueing events and

// event system but not native events. Should read window.event.type, like

// event time. The next update will compute a new event time.

// event's native "bubble" phase, which means that we're

// event. Then reset the cached values once we can be sure the event is

// events to their parent. We could also go through parentNode on the

// ever the previously attempted to render - not the "current". However,

// every

// everyone, because the strict mode case will no longer be relevant

// everything is batched by default. We'll then have a similar API to opt-out of

// example, if the current id is 23 bits long, we can convert 20 of those

// example, in the SuspenseList implementation.

// exceed it.

// exceeds the limit, we'll fire a warning.

// exception, let the outer generator proceed normally. If

// exception.

// exception. (Library authors do this to prevent users from using built-in

// execute code before the first await. Since we implement simple

// executor callback, and why async functions synchronously

// exiting a task.

// expiration time are props and context. We're already in the middle of the

// expiration times are an important safeguard when starvation

// expire after a render has already started.

// expired so we know to work on those next.

// export

// export native or passed

// export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

// export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

// expose properties, triggering a "Permission denied error" if any of its

// extend global

// extra objects for things that are never updated. It also allow us to

// fail the render phase where it didn't fail before. So we log it.

// fails when pasting 100+ items)

// fallback -> primary, the inner Offscreen fiber schedules this effect

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// fallback for not array-like ES3 strings and DOM objects

// fallback for not array-like strings

// fallback state, counts as the whole row being in a fallback state.

// fallback. Otherwise, don't capture and bubble to the next boundary.

// falls through

// false -> Array#indexOf

// false -> String#codePointAt

// fast apply, http://jsperf.lnkit.com/fast-apply/5

// fast case

// fast case for arrays with default iterator

// fast equal /^0b[01]+$/i

// fast equal /^0o[0-7]+$/i

// fiber associated with it.

// fiber. If beginWork throws, we'll use this to reset the state.

// fibers and continue.

// fibers, because that's the only place where we know how many children in

// fibers. We assume that return pointers never criss-cross, so A must

// filter

// filter it out using the allowed property list during the commit.

// final amounts. This seems counterintuitive, since we're intentionally

// find

// find that inner container before moving on to finding the parent

// findIndex

// finishes, the root will no longer be dehydrated.

// finishing. If there are too many, it indicates an infinite update loop.

// fire selectionchange normally.

// fire. The workaround for this bug involves attaching an empty click

// fires if there is an `Update` effect scheduled during mounting.

// fires only on input and textarea thus if there's no focused element we

// first entry

// fix Array#{values, @@iterator}.name in V8 / FF

// fix for some old engines

// fixed, the key warnings will appear.)

// flag logic (see #20043)

// flags have a lifetime only of a single render + commit, so we should

// flags in some other part of the codebase. This has happened before, for

// flags the flags after `commitReconciliationEffects` has already run;

// flow doesn't do during mount. This doesn't happen at the root because

// flush synchronous work at the end, to avoid factoring hazards like this.

// for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/

// for concurrent roots. And this method would only flush the legacy ones.

// for each null value. However, we also don't want to call updateSlot

// for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

// for hydration.

// for it to resolve before exiting the current scope.

// for now we can ship identical prod functions

// for that fake event. If the callback throws, the error is "captured" using

// for the error message.

// for this, we need to schedule that at a higher priority based on when it would

// for too long ("expired" work, to prevent starvation), or we're in

// for warnings.

// forced

// forward the event if the value has changed

// frame that called our sample function and the control.

// frames added by the construct call.

// from being lost during SSR hydration.

// from its placeholder state to its primary/resolved state.

// from the effect tag.

// from the first attempt, to preserve the causal sequence.

// from the latest value. The name "baseState" doesn't really match how we

// from the original lanes.

// frozen object case

// fully completes before restoring state.

// function and look at the tests that fail in ReactTransition-test.js. Try

// function as "disappearLayoutEffects" (or whatever that turns into after

// function), but there are some internal React features that use this as

// function, symbol are assigned as empty strings

// function. Warn to reserve for future use?

// function.sent implementation.

// functions in invokeGuardedCallback, and the production version of

// get `true` twice. That's probably fine?

// get an update and we'll never be able to hydrate the final content. Let's just try the

// get attached.

// get lost if this row ends up dropped during a second pass.

// get next entry

// get reset if `textContent` is mutated.  We could add a check in setTextContent

// get the case where the capture phase event might change

// get to the completed state slightly earlier.

// getDefaultExport function for compatibility with non-harmony modules

// getHighestPriorityLane because it requires the fewest operations.

// getModifierState. If getModifierState is not supported, we map it to a set of

// getSnapshotBeforeUpdate is called.

// gets it and catching keydown lets us fire an event for the first

// getting tag from 19.1.3.6 Object.prototype.toString()

// giving you warnings if you use production apis.

// global

// go straight to the fallback. Check the priority of the primary

// goes through Scheduler.

// going to wait for all of them anyway, it doesn't really matter

// hacks to make that not totally break. Like transferring effects and

// handled by `completeUnitOfWork` or `unwindWork`, but since we're

// handlers can run. See https://github.com/facebook/react/issues/708.

// happen after `updateDOMProperties`. Otherwise HTML5 input validations

// happened: you supplied an object or symbol value to React (as a prop, key,

// happens if the ctor or any wrappers processing the ctor throws. This might

// happens when a Suspense component is hidden. An extra fragment fiber

// has a different internal Fiber layout if you pass a normal function

// has a stable shape and so hopefully should be cheap to allocate.

// has already printed it. Even if the application swallows the error, it is still

// has been blocked.

// has ever gone from having children to deleting them or vice versa

// has no siblings nor a parent, we set it to null. Usually this is

// has this definition built-in.

// have been (and was previously) designed to take a closure to be

// have been in a layout effect. In that case, we would have used the old

// have been in an event that fired before the passive effects, or it could

// have finished. We can remove them from the shared queue, which represents

// have had an internalInstanceKey on it.

// have newProps so we'll have to reuse them.

// have not changed. Which is fine.

// have one on the alternate so we need to check in case this was a

// have reducer functions so it doesn't need rebasing.

// have set the values to before during the first pass. Ideally this wouldn't

// have timed out. In theory we could render it in this pass but it would have the

// have to consider _transitive_ entanglements. For each lane that is already

// have to detach the deleted tree at the root.

// helper for String#{startsWith, endsWith, includes}

// helpful for us so just check activeElement instead.

// higher priority.

// holds an emoji character like `\uD83D\uDE0A`.  Because its length

// hook updates, which are handled differently and don't reach this

// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.

// hooks for this fiber.

// host config, but because they are passed in at runtime, we have to thread

// host node but that wouldn't work for React Native and doesn't let us

// how <noscript> is being handled. So we use the same document.

// html.removeChild(iframe);

// https://bugs.chromium.org/p/v8/issues/detail?id=3443

// https://bugs.chromium.org/p/v8/issues/detail?id=8538

// https://bugzilla.mozilla.org/show_bug.cgi?id=208427

// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/

// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support

// https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

// https://github.com/facebook/react/issues/11768

// https://github.com/facebook/react/issues/11918

// https://github.com/facebook/react/issues/12502

// https://github.com/facebook/react/issues/12506

// https://github.com/facebook/react/issues/13188

// https://github.com/facebook/react/issues/14365

// https://github.com/facebook/react/issues/16585

// https://github.com/facebook/react/issues/16734

// https://github.com/facebook/react/issues/19099

// https://github.com/facebook/react/issues/19651

// https://github.com/facebook/react/issues/20756

// https://github.com/facebook/react/issues/22459

// https://github.com/facebook/react/issues/3877

// https://github.com/facebook/react/issues/7253

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim

// https://github.com/tc39/Array.prototype.includes

// https://github.com/tc39/proposal-global

// https://github.com/tc39/proposal-object-getownpropertydescriptors

// https://github.com/tc39/proposal-object-values-entries

// https://github.com/tc39/proposal-promise-finally

// https://github.com/tc39/proposal-string-pad-start-end

// https://github.com/websockets/ws/pull/645

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028

// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl

// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element

// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd

// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr

// https://infra.spec.whatwg.org/#ascii-tab-or-newline

// https://infra.spec.whatwg.org/#c0-control-or-space

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume

// https://tc39.github.io/ecma262/#sec-advancestringindex

// https://tc39.github.io/ecma262/#sec-getsubstitution

// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match

// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace

// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search

// https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split

// https://tc39.github.io/ecma262/#sec-regexpexec

// https://tc39.github.io/ecma262/#sec-string.prototype.match

// https://tc39.github.io/ecma262/#sec-string.prototype.replace

// https://tc39.github.io/ecma262/#sec-string.prototype.search

// https://tc39.github.io/ecma262/#sec-string.prototype.split

// https://tc39.github.io/ecma262/#sec-toindex

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

// https://url.spec.whatwg.org/#url-parsing

// https://v8.dev/blog/elements-kinds#avoid-creating-holes

// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts

// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html

// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream

// hydrate it. We might still be able to hydrate it using a higher priority lane.

// hydrated it yet. Even though we leave the comments in the

// hydration parent is the parent host component of this host text.

// hydrationCallbacks

// iOS Safari 7.x bug

// identifierPrefix

// identities match.

// idle updates until after all the regular updates have finished; there's no

// ie9- setTimeout & setInterval additional parameters fix

// if I do. eslint-disable-next-line no-fallthrough

// if a Content Security Policy forbids using Function, but in that case

// if a component just imports ReactDOM (e.g. for findDOMNode).

// if it will have any context consumers in it. The best we can do is

// if it's an async function.

// if it's pinged, assume it's CPU-bound. Compute a new expiration time

// if object isn't iterable or it's array with default iterator - use simple case

// if shouldComponentUpdate returns false.

// if someone has already defined a value or Safari, then bail

// if that one is still mounted.

// if the component re-renders for a different reason and by that

// if the update originates from user space (with the exception of local

// if there is no tracker at this point it's unlikely

// if there's any difference in memory impact. If there is, that could

// if this happens outside render or commit phase (e.g. in an event).

// if we're a child of a dehydrated container, we need to first

// iframe.contentDocument.defaultView;

// ignore it because `didError` will be false, as described above.

// ignore them.

// ignores it.

// immediately after.

// immediately observable. Otherwise, we assume that they are not

// immediately, wait for more data to arrive.

// immediately, without awaiting.

// implementation detail.

// implementation of `act` behaved.

// implementations of a working draft specification.

// implemented in any major browser. Only KeyPress has charCode.

// implications, it's considered a recoverable error, even though the user

// important to get this right, even though it requires care.

// in DEV mode if this property exists or not and warn if it does not.

// in SchedulerMock. To reduce the noise in strict mode tests,

// in a batch that does not also include the other lane. Typically we do this

// in a separate file to break a circular dependency between the renderer and

// in case runtime.js accidentally runs in strict mode, in modern engines

// in case the event system needs to trace it.

// in case they schedule additional work.

// in every case, so we don't have to touch the arguments object. The

// in fallback state. Then we render each row in the tail one-by-one.

// in our config atm.

// in that browser completely in favor of doing all that work.

// in the "together" mode, so we can continue from the state we had.

// in the bubble phase, so we need to accumulate two

// in the case of a refresh, we'll never commit a fallback. So we need to

// in the concurrent tree already suspended during this render.

// in the first place because we used to wrap it with

// in the legacy event system, except the big difference between

// in the meantime, we can add/remove/change items and dependencies.

// in the stack.

// in this optimized path, mostly pushing stuff onto the stack.

// include every environment we run tests in), so the test framework

// included in the current render. Usually, the priority level of the

// includes all pending updates are included. If it still fails after

// index

// indicate a React leak we don't know about.

// indicate that it still has pending work.

// infinite loop, because it iterates over the newly added props too.

// information on the fiber.

// inherited deeply down the subtree. The upper bits only affect

// initial value. In IE10/IE11 there is a bug where the placeholder attribute

// injected easily by `bin/regenerator --include-runtime script.js`.

// inputs to the algorithm must be the same.

// inserted into the React tree here. It just happens to not need DOM

// inserted, before any life-cycles like componentDidMount gets called.

// inserted.

// inside `componentDidCatch` is itself flawed — that's why we recommend

// inside a hidden Offscreen tree.

// instance. Note that we don't check this field on  the targetNode

// instead of early flushing them here.

// instead of the ES6 spec version, we didn't implement @@toPrimitive case

// instead.

// intentionally don't throw our own error because this is in a hot path.

// intentionally not calling those, we need set it here.

// interleaved event. Regardless, this pattern is not officially supported.

// interleaved list to the end of the pending list by joining them into a

// intermediate loading state. So we use heuristics to determine when.

// internal queue

// interrupted, the interleaved updates will be transferred onto the main part

// into the async generator function so it can be handled there.

// into their subtree. There are simpler cases in the inner switch

// invalidates the heuristics of the event plugin. We

// invariant for a missing parent, which is super confusing.

// invocations of the iterator.

// invokeGuardedCallback uses a try-catch, all user exceptions are treated

// invoked without arguments, but in all the cases we care about we

// is 2, the property `which` does not represent an emoji correctly.

// is a new ref we mark this as an update.

// is a new ref we mark this as an update. All the work is done in commitWork.

// is active that we have to do anything special.

// is changed from JS so we redefine a setter for `.value` that updates

// is inserted in between the Suspense fiber and its children. Skip

// is not resilient to the DOM state changing so we don't do that here.

// is often used for testing purposes.

// is one of the very rare times where we mutate the current tree

// is to access a property that typically works for non-anonymous divs and

// is to detect whether something might have called setState inside

// is to tell small differences in time. Therefore, the longer we've already waited,

// is why the Promise constructor synchronously invokes its

// isBackwards

// isStrictMode

// issue if key is also explicitly declared (ie. <div {...props} key="Hi" />

// it and we'll lose our progress. We should only do this if the new lanes are

// it are either exclusive to concurrent mode or exist in both.

// it at the keypress level and bail immediately. Android Chrome

// it cannot be shared with the current fiber.

// it captures the suspended "exception" and does a second (fallback) pass.

// it causes problems. This is meant to give a nicer error message for

// it doesn't make sense to restart only while in the period we're suspended.

// it doesn't resuspend. So we can't let the call below suspend.

// it during the first pass. Instead, we'll reenter it later.

// it from the child list so that we don't add it to the deletion

// it is possible that no option is selected.

// it might make more sense for the queue to be a list of roots instead of a

// it probably isn't that urgent.

// it up in a passive effect.

// it would have deleted the dehydrated boundary nested inside already.

// it's already rendering, we won't interrupt it. This is intentional, since

// it's not part of the same transition once the transition has

// it, on the update object. If the reducer hasn't changed by the

// it, so set the completion value of the entire function to

// it. If it has no children, this is still the first loop, and the only

// it. Using NoLane works because 0 is a subset of all bitmasks, so

// iterator prototype chain incorrectly implement this, causing the Generator

// its effects.

// its parent.

// its thenables. Instead, we'll transfer its thenables to the

// itself because the fibers are conceptually between the container

// itself should capture it.

// itself. They will be added to the side-effect list as we pass through the

// keep track of whether it suspended or not.

// key is explicitly declared to be undefined or not.

// key, when multiple keydown events are fired but only one keyup is.

// keys

// keys quickly. Implicit (null) keys get added to this set with their index

// keystroke if user does a key repeat (it'll be a little delayed: right

// keyup, but we check on keydown as well in the case of holding down a

// kind

// lanes in the same batch, but it's not worth throwing out partially

// last

// last entry

// last error event is always used. If the callback actually does error,

// last rendered item.

// last sibling.

// later and not trigger anything as the state now

// layout effects, and so on.

// layout phases. Should be able to remove.

// lazily which won't cover if the log function was extracted eagerly.

// leak store for uncaught frozen objects

// left in the tail. We'll just give up further attempts to render

// legacy API.

// length should be 1, old FF problem

// libraries need to call batchedUpdates. Eventually, this API will go away when

// like a proxy to Context. This proxy object adds unnecessary code in PROD

// like caught exceptions, and the DevTools won't pause unless the developer

// like forwardRef (MemoComponent). But this is an implementation detail.

// likely unblocked. Try rendering again, at a new lanes.

// likely won't observe anything wrong with the UI.

// line, that's a pretty good indicator that our sample threw at same line as

// list itself.

// list of generic callbacks. Then we can have two: one for legacy roots, one

// list.

// listener on the target node.

// listener. This one schedules an update on the Suspense boundary to turn

// listeners still fire for all the media events.

// listeners still fire for error and load events.

// listeners still fire for the error event.

// listeners still fire for the invalid event.

// listeners still fire for the load event.

// listeners still fire for the toggle event.

// listeners.

// lists and take advantage of structural sharing.

// live outside of this function.

// localIdCounter = 0;

// location outside the try/catch block.

// locations where there is no enclosing try statement.

// logic applies: when re-connecting, the Offscreen fiber's complete

// logic is located in this special branch.

// lol @ IE not supporting String#repeat

// loop instead of recursion so we can exit early.

// lot of unnecessary work and is unlikely to complete since it often will suspend

// lower priority work to do. Instead of committing the fallback

// main reasons this is so complicated.

// make static versions for prototype methods

// make this module simpler.

// makes sense elsewhere

// map

// mark it as having updates.

// may entangle more than we need to, but that's OK. In fact it's worse if

// may not be work scheduled on `current`, so we check for this flag.

// may throw

// means `flushPassiveEffects` will sometimes result in additional

// meant to be awaited.

// memoized props/state to indicate that this work can be reused.

// memoized state to indicate that this work can be reused.

// method, or a missing .next mehtod, always terminate the

// methods are needed to perform accurate arithmetic or comparison.)

// might be flawed or unnecessary.

// might get scheduled in the commit phase. (See #16714.)

// might match additional HTML that is hidden when we read it using

// might unsuspend it, and vice versa. The only reason to suspend is

// minifier not to mangle the names of these two functions.

// miss anything.

// missed a blur event somehow.

// mixing React radio buttons with non-React ones.

// modifier keys exposed by the event. In this case, Lock-keys are not supported.

// more than we need to, but that's OK. In fact it's worse if we *don't*

// most Object methods by ES6 should accept primitives

// most batchedUpdates-like method.

// mounted but this is a new fiber.

// mounted fiber is the parent but we need to continue to figure out

// move this assignment out of the common path and into each branch.

// moved from outside the window (no target) onto the target once it hydrates.

// multiple times.

// must have finished. We can remove them from the shared queue, which

// mustUseProperty

// mutated. We have already warned for this in the past.

// mutations because it already exists.

// name warnings.

// need an additional field on the work in progress.

// need to delete the existing child.

// need to mark fibers that commit in an incomplete state, somehow. For

// need to validate that the fiber is a host instance, otherwise

// needing to surface it to the UI. We log them here.

// nested `invokeGuardedCallback` calls do not clash. Otherwise, a

// nested call would trigger the fake event handlers of any call higher

// nested within a dehydrated boundary and if so, which one.

// never be thrown again.

// never bubble through the *DOM* tree unless an ancestor with onclick

// new markup in a temp node and then move the child nodes across into

// new one.

// new. If a row has multiple Suspense boundaries, any of them being in the

// next commit. This handles the case of React rendering into a

// next event, not at the end of the previous one.

// next index

// next state before entering the render phase. If the new state is the

// no longer at the top of the stack.

// no more pending effects.

// node and the first child. It isn't surrounding the container node.

// node from the tree.

// node has fully mounted yet, and for scheduling event replaying.

// node that is from the other tree.

// node that we're free to reuse. This is lazily created to avoid allocating

// node.

// node. Unfortunately, if multiple insertions are done in a row we have to

// non-alphabetical order. Handling that would require sorting CSS

// non-interactive elements, which means delegated click listeners do not

// non-printable. One would expect Tab to be as well (but it isn't).

// nonDelegatedEvents list in DOMPluginEventSystem.

// nor polyfill, then a plain number is used for performance.

// normal children even if their identities match.

// normal rules of React, and only works because store updates are

// normalized. Since it only affects IE, we're skipping style warnings

// not defined.

// not enabled yet

// not have a clone, that means it wasn't processed, and the updates were

// not in the capture phase. That's because we emulate

// not measuring part of the render phase, but this makes it match what we

// not necessary to add metadata

// notch on the scroll is always +/- 120, roughly equivalent to pixels.

// nothing should rely on this, but relying on it here means that we don't

// now I'll disable the warning that most of the bugs that would trigger

// now unblocked. This first might not actually be unblocked yet.

// null and keep rendering. When the Suspense boundary completes,

// number of `act` scopes on the stack.

// numeric operators like `+` or comparison operators like `>=` because custom

// object ID

// object to not be returned from this call. This ensures that doesn't happen.

// object will not have any of these fields. It will only be connected to

// objects. For full spec compliance, you may wish to configure your

// obnoxiously named function :)

// of DevTools integration and associated warnings and logs.

// of `act`.

// of priority this work has the same priority as this current render,

// of such a refactor, all the hydration logic is contained in

// of the effect list for each phase: all mutation effects come before all

// of the existing task is the same as the priority of the next level that the

// of the polyfill.

// of the preceding one.

// of the queue.

// of this function.

// of what it is. No need to defer it.

// offscreen subtree was already hidden, so that we don't unmount the

// ok not to if the visible content is still enough to indicate what

// old behavior is to give this the same "thread" (lanes) as

// on any nested boundaries to let them know to try to render

// on it

// on its children. We'll use the childLanes on

// on missing data anyway. Additionally, the server might be able to render more

// on the client side because the browsers are inconsistent. Instead we call focus().

// on the client than if we just leave it alone. If the server times out or errors

// on the root.

// on the server.

// one doesn't include any removeChild logic. This is maybe the same

// one, too.

// one. This works because the bits decrease in priority as you go left.

// only additional allocation required is the completion record, which

// only be updated if work is done on the fiber (i.e. it doesn't bailout).

// only codepath.)

// only difference between default updates and transition updates is that

// only ever need at most two versions of a tree. We pool the "other" unused

// only other reason this optimization exists is because it affects profiling.

// opportunity later. So we mark this render as having a ping.

// opportunity to paint.

// opt-in behavior for better messages but that we won't stop

// option and select we don't quite do the same thing and select

// optional / simple context binding

// or <div key="Hi" {...props} /> ). We want to deprecate key spread,

// or a finally block) gives us a place to store values thrown from

// or boolean value assignment. Regular attributes that just accept strings

// or commit so we need to check against that.

// or completeWork depending on whether we want to add them top->down or

// or finish the iteration

// or not, return the runtime object so that we can declare the variable

// or, if something suspended, wait to commit it after a timeout.

// order may not be the same as the new order. We use the new order.

// order-dependent and do not need to be observed by external systems, so we

// order.

// other events and have it go through ReactBrowserEventEmitter. Since it

// other nodes in them. We also ignore components with pure text content in

// our activeElementValue variable, allowing us to ignore those changes

// out is legacy mode; every concurrent path provides an error).

// out known bad ones like `onclick`. We can't suggest a specific replacement though.

// out the setState warning, since existing code might accidentally rely on

// outer generator.

// over and traverse parent path again, this time treating the exception

// over the nested children entirely. An exception is we haven't yet found

// over this extra fragment fiber and proceed to the next parent.

// over. Our heuristic for that is whenever we enter a concurrent work loop.

// overwritten while composition continues.

// painted. Conceptually, this is really the same as pinging.

// parallel threads. This would represent the beginning of a new render

// parent boundary that hasn't above this one so we need to find

// parseInt parses a string to a first unavailable symbol

// parsing rules -- if we're down here, then none of those matched and

// part of a list of children (arrays, iterators).

// part of the second pass. In that case nothing will subscribe to

// particular fiber, it won't leak anything else

// pass entirely and go straight to rendering the fallback. (In Concurrent

// pass null in place of where we usually pass the current child set. This has

// pass the Container node as the targetNode, you will not actually get the

// pass through beginWork to rerender all children (including the tail) with

// passed inline.

// passing it to React. The most reliable way is usually `String(value)`.

// passing null.

// passing the value through getToStringValue first.

// passive by default on document. React doesn't bind them

// passive effects. So we need to keep flushing in a loop until there are

// path from the normal path. I'm tempted to do a labeled break here

// path to compute the correct tail.

// path. This would exclude suspended updates in an unrelated sibling tree,

// pending level.

// pending time is whatever is left on the root fiber.

// pending updates to the end of the list and keep processing.

// performing a second pass to render a fallback. (This is arguably how

// phase event listeners (via emulation).

// phase event listeners.

// phase introduces a potential mistake where we suspend lanes that were

// phase update. In that case, we don't treat render phase updates as if

// phase will handle scheduling the effect. It's only when the fallback

// phase, which we are now aborting. Remove the updates from the queues so

// phase. So we need to schedule its effect here.

// phase. They should be discarded if the render is aborted. Therefore,

// phase. This is a refactor hazard because it means we must read

// physical keyboard key.

// pinged or updated while we were rendering.

// placeholder and without scheduling a timeout. Delay indefinitely

// placement for inserting new children.

// please ensure we do the following:

// plugin (BeforeInput, Change, Select). The state in

// plugin. However, the plugins below either expect

// point to the last node in a circular linked list. We need to append the

// possible for anything else to have happened in between our callback

// post mount to force it to diverge from attributes. However, for

// pow(2, 53) - 1 == 9007199254740991

// pretend the suspended fiber committed as `null` won't work,

// prevent a bail out.

// prevent global pollution for namespaces

// previous render was null (so the container would already

// previous value and spawn a deferred render to update it later.

// previously was rendered in its fallback state. One of the promises that

// primary -> fallback, the inner Offscreen fiber does not have a complete

// primary tree will commit in an inconsistent state, so when we do the

// printable characters (normalized to `Unidentified`), ignore it.

// priority for this boundary.

// priority within React itself, so we can mutate the variable directly.

// priority. Bailout.

// priority: the bailed out fiber's child reuses the current child.

// probably just combine the two functions. I believe they were only separate

// problem and how that type was used: key, atrribute, input value prop, etc.

// problems, please detail your unique predicament in a GitHub issue.

// process the abstract event manually.

// process them during this render, but we do need to track which lanes

// process them now.

// processUpdateQueue, but that didn't happen in this case because we

// profiler durations.

// properties are accessed. The only seemingly possible way to avoid erroring

// properties in the client & server versions or applying

// properties:

// property, it may be the creator of the child that's responsible for

// propertychange on the first input event after setting `value` from a

// proto

// provides a surprisingly accurate mapping for US and European users.

// pushHostContext() only pushes Fibers that provide unique contexts.

// queue -> linked list of updates. After this render pass, we'll restart

// queue is a singly-linked list with no cycles, we can append to both

// queue is in the render or commit phases.

// queue so we can process it immediately during the current render.

// queue until there's no remaining work.

// queueing is accumulative.

// raise warnings and prevent the new value from being assigned.

// rarely, since we try to avoid it) updated during the render phase.

// rather than attributes. These are all booleans.

// rather the ids be wrong than crash the whole reconciler.

// rather, it wraps around an inner component, which may or may not

// re-initializing custom elements if they exist. But this breaks

// re-render a fallback. This is temporary until we migrate everyone to

// read from the store.

// read it during an event

// read require off the module object to get around the bundlers.

// real proto method for `library`

// recent event, and we assume time is monotonically increasing.

// reclaim the extra memory if needed.

// reconciliation

// record like context.tryEntries[i].completion. This interface could

// recoverable errors during first hydration attempt. If so, add

// reduce size and overhead. The separate object references context via

// refresh transitions should work, too, since we're not going to commit

// regeneratorRuntime in the outer scope, which allows this module to be

// rely on mutating the flag during commit. Like by setting a flag

// remain on that fallback regardless of whether the content has resolved.

// remaining digits.

// remaining updates is accumulated during the evaluation of the

// remove from the queue because you can't remove arbitrary nodes from an

// remove the special case and treat them as if they came from an

// removed.

// render and there's another warning for that anyway.

// render pass will run to completion or restart or "suspend" the commit.

// render phase update. It assumes there is either a current hook we can

// render something, if we time out. Even if that requires us to delete everything and

// render synchronously to block concurrent data mutations, and we'll

// render. If this fires, it suggests that we incorrectly reset the static

// render. In that case it should not bubble. We determine whether it was

// render. When this render exits, either because it finishes or because it is

// renderLanes from the original lanes.

// rendered in the same callstack as the parent.

// renderer.

// rendering it again.

// rendering the fallback children.

// rendering. We might want to restart this render. This should mirror

// replaying on render function. This currently only patches the object

// report Enter as charCode 10 when ctrl is pressed.

// represents a superset of the actually pending lanes. In some cases we

// represents an intermediate state, which we don't want to show to the user.

// required — every concurrent mode path that causes hydration to

// rerender the children.

// result, either by returning a { value, done } result from the

// retries or transitions). It's been like this for a while, though, so fixing

// retries so that we don't show too many loading states too quickly.

// return primitive with prefix

// return step by kind

// revealOrder undefined can't be trusted because it don't

// revert to the last existing entry

// root boundaries that match that of our current "rootContainer".

// root has work on. This function is called on every update, and right before

// root.

// root; if a task was already scheduled, we'll check to make sure the priority

// row at the tail. So we'll keep on and cut off the rest.

// run out of lanes and cycle back to the beginning.

// safe

// same as the current state, we may be able to bail out entirely.

// same batch.

// same children then we're still in progressive loading state.

// same error.

// same fiber again.

// sanitizeURL

// satisfies our requirement. Our requirement is not to produce perfect

// schedule a callback until after flushing layout work.

// schedule a side-effect to do the updates.

// schedule a visibility effect.

// scheduleCallbackForFiber to preserve the ability to schedule a callback

// scheduled before we entered the render phase.

// scheduled work and instead do synchronous work.

// scraping the MDN documentation.

// script and fires only keydown, keypress, keyup. Catching keyup usually

// search past them. This leads to exponential search for the next sibling.

// second pass to render the fallback, we do some exceedingly, uh, clever

// selection (this matches native `select` event behavior). In HTML5, select

// self and source are DEV only properties.

// semantics of the native select event.

// separate function to avoid using an array tuple.

// separate issue. Write a regression test using string refs.

// sequence of characters.

// set of B.return.

// set them on the actual target element itself. This is primarily

// set to `true` while the given callback is executed, not for updates

// set to true and it does not execute

// setting context.delegate to null, and returning the ContinueSentinel.

// setting it the first time we go from not suspended to suspended.

// should be invisible. If there are already mounted boundaries

// should immediately commit it or wait a bit.

// should probably be inlined somewhere and have its logic

// should work with symbols and should have deterministic property order (V8 bug)

// shouldComponentUpdate is tricky; but we'll have to account for

// showing an intermediate loading state. The longer we have already waited, the harder it

// showing content on the screen, as opposed to being in fallback state or

// sibling order but that isn't a strong guarantee promised by React.

// sibling, or the parent if there are no siblings. But since the root

// sibling. If there are no more siblings, return to the parent fiber.

// siblings.

// side of them. We also don't delete anything inside the root container.

// since it doesn't have to consider all Suspense boundaries and

// since it's known to be in an inconsistent state. Use a force update to

// since the rest will all be insertions.

// since there's no way for this update to unblock it.

// since we now have higher priority work, but in case it doesn't, we need to prepare to

// since we're leaving it behind on this node.

// single type, like a DynamicHostConfig that is defined by the renderer.

// single, circular list.

// size

// skip hydration.

// skip the consistency check in that case, too.

// skipped over the parent when we bailed out.

// skipped update, the previous update/state is the new base

// smell because it assumes the commit phase is never concurrent with

// snapsho and getSnapshot values to bail out. We need to check one more time.

// so let's just skip over it to find memo() outer wrapper.

// so that e.g. DevTools can display custom hook values.

// so that our component-stack generation logic will display their frames.

// so that results are always delivered in the correct order. If

// so that the async generator function has the opportunity to do

// so the stack is accurate.

// so we allow it only if we don't know what the parent is, as all other

// so we assign defaultValue to the same thing as the value property

// so we can always restart.

// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.

// so we have to do it now instead.

// so we should bubble those up even during a bailout. All the other

// so we try MessageChannel+postMessage instead

// so we use the old behaviour (Context.Consumer references Context) to

// so we won't be able to report the time spent in this Profiler's subtree.

// so we'll just enter that. The only difference is we'll bail out

// so we'll print it first, and then print the stack addendum.

// solution. The value can be a boolean or object so that's why it's forced

// some

// some WebKit versions fails with big numbers, some has wrong arity

// some renderers as primary and others as secondary. We only expect

// something either suspended or errored.

// sometimes bails out later in the begin phase. This indicates that we should

// sometimes when it hasn't). IE's event fires out of order with respect

// spaces, for instance (\u3000) are not recorded correctly.

// special cases and we'll deal with them.

// special to do. Need to push to the stack regardless, though, to avoid

// splice it in to make the stack more readable.

// state

// state of the host tree right before we mutate it. This is where

// state since we're now exiting out of it. popHydrationState doesn't do that for us.

// state, no effects. Same as what we do for Offscreen (except that

// state, only for the following bubble event to come in

// state. Now that we have additional work, cancel the timeout.

// stateNode is any.

// statement, but eslint doesn't know about invariant, so it complains

// static

// statics

// stepped past dehydrated DOM nodes to get here. However they could

// still log it so it can be fixed.

// still need to keep traversing to unmount effects, refs, and cWU. TODO: We

// still want to warn on the client.

// stopWatching() should be a noop here but we call it just in case we

// store a single event to be replayed.

// store all the rest on native weakmap

// store frozen objects on internal weakmap shim

// stores were mutated in a concurrent event. Intentionally using an iterative

// stores were mutated.

// strange IE + webpack dev server bug - use .call(global)

// strict mode using a global Function call. This could conceivably fail

// style object but the events that fire will still be prefixed, so we need

// sub-tree for that root and make that our ancestor instance.

// subtree includes a nested portal.

// succeed and there will likely be errors in render.

// sufficient to fix memory issues, that bodes well for our plans.

// superfluous and we'll delete it. Since we can't eagerly delete it

// support window.event.

// supports within in a single renderer. Such as parallel server rendering.

// supposed to capture all errors that weren't caught by an error

// suppress warnings and disable scheduler yielding during the double render

// suspend for longer if possible.

// suspend the commit. Pretend as if the suspended component rendered

// suspended it has resolved, which means at least part of the tree was

// suspended level. Ping the last suspended level to try

// suspended now, right before marking the incoming update. This has the

// suspended render.

// switch to the regular, concurrent mode behavior: mark the

// sync-updates-by-default mode.

// synchronous update. We should have already checked for this when we

// synchronous updates. If that theory is correct, the proper solution is

// synchronously at the end of the current task so that the result is

// synchronously to block concurrent data mutations, and we'll includes

// synchronously to maintain consistency with external state.

// synchronously, to block further mutations.

// systems is that the modern event system now has an event listener

// tags get no namespace.

// tail

// takes the extra step of enabling pause on caught exceptions. This is

// target

// techniques harder. Instead, if `scheduledHostCallback` errors, then

// textContent. E.g. "foo" will match "f<span>oo</span>" but that still

// than once; for example, if non-React code also calls `dispatchEvent`

// than we can on the client yet. In that case we'd end up with more fallback states

// that are shown on error are two different sets, so we shouldn't reuse

// that child fiber is setting, not the reconciliation.

// that could already be hydrated, we wouldn't have found them

// that don't modify the stack.

// that happens later in the same render, it will flush. Ideally, we want to

// that has been unmounted.

// that is eventually read during hydration.

// that might cause other unknown side-effects that we

// that plays more nicely with the browser's DevTools. The idea is to preserve

// that regardless.

// that represents the position of this useId hook among all the useId

// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the

// that the "current" fiber pointer gets updated so we need a commit

// that the "current" props pointer gets updated so we need a commit

// that there was an interleaved update work on this root. Unless the

// that trying again will succeed

// that was thrown. It's possible that this error handler will fire more

// that we can show the initial loading state as quickly as possible.

// that we don't block potential future ES APIs.

// that we first we try to render one tree, and if that fails, we render again

// that weren't processed.

// the 'y' flag.

// the .value of the Promise<{value,done}> result for the

// the DOM node back to the controlled value. This is necessary when React

// the DOM nodes representing these roots are the "rootContainer".

// the React name like we do for attributes that exist only in HTML.

// the `act` queue instead.

// the `possibleStandardNames` module to ensure casing and incorrect

// the actual printable character.

// the allowed property list in the commit phase instead.

// the base state unless the queue is empty.

// the begin phase to prevent an early bailout.

// the begin phase. There's still some bookkeeping we that needs to be done

// the callback doesn't error, but the error event was fired, we know to

// the capture phase here still. This is a trade-off,

// the commit side-effects on the root.

// the component is rerendered and the value reverted before all the event

// the content is stale, it's already visible anyway. Instead we'll patch

// the control. I.e. before we entered the sample frame. So we ignore this result.

// the current behavior.

// the current tree; see previous branch.)

// the deleted tree. In the meantime, do not add this warning to the

// the developer's perspective, the error is uncaught.

// the different event systems have different DOM event listeners.

// the dispatcher used for mounts.

// the earliest expiration time on the root. Then use that to quickly bail out

// the effect of remounting all children regardless of whether their

// the error. Bubble it to the next boundary.

// the event in the out event of the other target. If this is replayed,

// the existing behavior manually on the roots now.

// the existing children. Conceptually, the normal children and the children

// the fact that we have it is the same as the expected.

// the fallback state off.

// the fallbacks anyway.)

// the fiber has not been cloned though, (meaning no work was done), then

// the fiber tree via a single link at the root. So if this level alone is

// the final result produced by the iterator.

// the first ancestor. Next time, we will ignore the event.

// the first item in the list.

// the first pass, we schedule a deletion for all the current children by

// the force suspend context. If the first render didn't have anything in

// the future if we implement resuming, or some form of that.

// the hottest path, and Object.assign() was too slow:

// the hydration callbacks.

// the hydration is successful of a javascript: URL, we

// the input might not even be in a form. It might not even be in the

// the lane finished since the last time we entangled it. So we need to

// the layout phase is refactored to use recursion).

// the list will propagate the change when it rerenders.

// the logic of whether or not a root suspends once it completes.

// the longer we can wait additionally. At some point we have to give up though.

// the main content and only render fallbacks.

// the method takes exactly one argument, since that happens to be true

// the most recent event from that source.

// the mutation phase, so that the previous tree is still current during

// the new API.

// the newly allocated props object.

// the next tick, or earlier if something calls `flushSyncCallbackQueue`.

// the only reason we track the event time, then probably not.

// the order matters. We should refactor so that ContentReset does not

// the other context values.

// the other plugins are essentially polyfills. So the plugin

// the outer generator.

// the outer most that is known.

// the performance wins from the change. So we emulate

// the phases properly, like we do with the SimpleEvent

// the previous (alternate) parent fiber's list of children. Because

// the previous render and commit if we throttle the commit

// the problematic code almost always lies inside that component.

// the proper solution is to fix the accidental strict mode problem. If

// the reconciler.

// the render phase of the fork parent, not the child, which is where we push

// the render phase.

// the render phase. Will address during refactor to alternate model.

// the renderer. Such as when we're dispatching events or if third party

// the rest.

// the root always starts with a "current" with a null child.

// the sample somewhere in the control.

// the second attempt, we'll give up and commit the resulting tree.

// the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and

// the stack without entering the complete phase. If this is a boundary,

// the stack.

// the target fiber to a different ancestor. We had similar logic

// the target node

// the topmost host node to delete, which we already track on the stack.

// the tree, it is using a ref to a child-less DOM node.

// the un-prefixed "animation" and "transition" properties are defined on the

// the unwanted keypress events. Enter is however both printable and

// the update queue. However, there's an exception: SimpleMemoComponent

// the update to schedule work on the root fiber (and, for legacy roots, to

// the updates that were skipped. Usually we only suspend at the end of

// the user does something weird like await the thenable

// the validation flag non-enumerable (where possible, which should

// the way we push/pop these values is a bit unusual. If there's a mistake, I'd

// the whole set without doing extra work later, or storing addtional

// the whole system, dispatch the event without a target.

// the whole system.

// the work-in-progress hook.

// the wrapperState._initialValue property. This uses:

// the wrong context.

// their priority set by tracking it with a context variable.

// them again.

// them got retried so they'll still be blocked in the same way

// them through the root constructor. Perhaps we should put them all into a

// them to a queue so we can log them in the commit phase.

// them to the collection of recoverable errors. We'll log them in the

// them to update.

// then don't suspend/restart.

// then it needs to call setState to recover from errors.

// then it's because we couldn't dispatch against this target previously

// then let that catch block handle the exception normally.

// then the tail doesn't matter. Anything new that suspends will work

// then we suspend/restart for 500ms since the last time we showed a fallback

// then we would risk falsely saying two separate memo(Foo)

// there are also other cases when this might happen (such as patching

// there are any.

// there may have been recoverable errors during first hydration

// there to be two concurrent renderers at most: React Native (primary) and

// there's a new task, or that there's no remaining work on this root.

// there's a user interaction that's being starved by a series of

// these aren't boolean attributes (they are coerced to strings).

// these fields are relevant.

// these modules complicates things, as you'll essentially

// these should update this boundary to the permanent Fallback state instead.

// they are left as they are instead.

// they do not persist to the next render. Do not remove updates from hooks

// they should be.

// they use separate lanes is because continuous updates should interrupt

// they were interleaved, for backwards compat reasons.

// things simple and return the next function itself.

// this as an update to prevent the fiber from bailing out.

// this branch.

// this can happen all the time, but even in synchronous mode, an earlier

// this case.

// this fiber to indicate that a context has changed.

// this fiber. This is for backwards compatibility in the case where you

// this immediate suspense boundary and gets reset each new

// this in the host environment that also has access to this prop. That

// this is needed to work around a chrome bug where setting defaultChecked

// this is no longer necessary.

// this may also return a SuspenseComponent or HostRoot to indicate that.

// this render is thrown away. Since it's a race condition, not sure it's

// this render.

// this value will reflect the amount of time spent working on a previous

// this whenever subscribe, getSnapshot, or value changes. Because there's no

// this will never be skipped by the check above.

// this wrapper function to constrain it.

// those cases. Even if our error event handler fires more than once, the

// those special-case tags.

// those trigger a fallback, then don't suspend/restart. We want to ensure

// thread for this subtree.

// through Scheduler

// through the React tree. However, on Mobile Safari the click would

// through this pass since if the target is hydrated it would

// throw (to help callers find troubleshooting comments)

// throw the exception.

// thus be captured by `keypress`, no other non-printable key should.

// time it takes to show the final state, which is what they are actually

// time the reducer has changed.

// time we apply the entanglement.

// time we enter the render phase, then the eager state can be used

// time we have to render. So rendering one more row would likely

// time. This will mean that Suspense timeouts are slightly shifted to later than

// to a SimpleMemoComponent to allow fast path updates.

// to account for it here, too. Reset to the value of the current fiber.

// to add them to the deletion list.

// to arrive.

// to attempt to render the primary children again.

// to avoid a push/pop misalignment.

// to be a string.

// to be able to optimize each path individually by branching early. This needs

// to be removed, such as transitioning from a checkbox into a text input

// to check for the existence of `firstEffect` to satisfy Flow. I think the

// to check if the un-prefixed events are usable, and if not remove them from the map.

// to consolidate.

// to create a new function object. We can even get away with assuming

// to delete it.

// to document anymore, but changing this now would undo

// to fix the starvation. However, this scenario supports the idea that

// to forget to do before returning it. E.g. for the single child case.

// to get it started back up to attempt the next item. While in terms

// to indexed object, toObject with fallback for non-array-like ES3 strings

// to its own fiber type so that we can add other kinds of hydration

// to key and input events on deletion, so we discard it.

// to only set the value if/when the value differs from the node value (which would

// to reconcilation, because those can be set on all fiber types.

// to resolve. Set it as pending in the meantime.

// to schedule a side-effect to do the updates.

// to schedule work on. In this case we have to schedule it on the

// to see if one of its parents is a React owned DOM node.

// to see what path the root points to. On the way we may hit one of the

// to stay in place.

// to store it in pendingPassiveTransitions until they get processed

// to the current tree provider fiber is just as fast and less error-prone.

// to the end. This breaks the guarantee that life-cycles fire in

// to the main thread, if it was fast enough, or if it expired. We could

// to this case. If none is defined, JND is used instead.

// to throw, e.g. if it has a cross-origin src attribute.

// to unblock.

// to update this element.

// track of how many dependencies remain but it gets tricky because

// transitions, but default updates should not.

// traverseAllChildren used to do for objects as children

// tree during the commit phase. This would make insertions faster, too.

// tree is part of a hydrating tree. This is used to determine if a child

// tree which will affect the tail. So we need to use the normal

// tree, which has its own pointers to children, parents, and siblings.

// tree.

// tree. To do this we can use getClosestInstanceFromNode, but we

// trees. What it should instead do is propagate the error to the parent of

// triggered during an async event, because this is how the legacy

// true  -> Array#includes

// true  -> String#at

// try rendering the tree again.

// try to extract the composed characters from the fallback object.

// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake

// try-catch. Neat!

// type bitmap

// type of the event.

// type. They needs to happen after the children effects have fired, but

// typeof check of "unknown" circumvents this issue (and is also

// types supported by any Flight configuration anywhere since

// unfortunate because it triggers the slow path all the time. We need

// unhandled rejections tracking support, NodeJS Promise without it fails @@species test

// unified ._invoke helper method.

// unintuitive, though, because even though React has caught the error, from

// unlike current.memoizedProps which will be the unresolved ones.

// unmount all the children. componentDidCatch will schedule an update to

// unmounted.

// unnecessary entanglement?

// unravel them when transferring them to the base queue.

// until `blur` in IE8.

// until we receive more data.

// unwanted click events.

// unwound the stack.

// unwrap

// up mounted layout effects, and call componentWillUnmount.

// up necessary since we never stop tracking anymore.

// up text content during hydration mismatch). So we'll check this again.

// up the fiber tree from the target instance and attempt to find

// up/down buttons on an <input type="number">. Anonymous divs do not seem to

// update a different component during render phase than the one that is

// update in the past but didn't complete it.

// update to the current fiber, too, which means it will persist even if

// update/state.

// updates at the same priority within the same event. To do this, the

// updates too, because current.child would only be null if the

// updates) to a group of lanes (used for flushing work).

// updates, to preserve historical behavior of legacy mode.

// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.

// us to ship builds of React without the polyfilled plugins below.

// use as a base. When we reach the end of the base list, we must switch to

// use it because we're reusing a state hook field instead of creating a

// use make it a noop by treating it as the default revealOrder.

// use that directly.

// useMutableSource, we should ensure that there is no partial work at the

// useful, so we don't use it.

// using `which`.

// using the current time.

// valid selection is anchorNode and focusNode both equal to this node

// value. The name doesn't really match how we use it because we're reusing

// value="" should make a value attribute (#6219)

// values.

// variable length - can't use forEach

// variable specified by delegate.resultName (see delegateYield).

// version of setImmediate, bypassing fake timers if any.

// visual feedback, "flashing" outermost parent rectangles is sufficient.

// w/o altered newTarget, lot of arguments case

// w/o altered newTarget, optimization for 0-4 arguments

// wait until the next time we yield.

// waiting for.

// want to reconcile without matching against the existing set. This has the

// warnings.

// warns for updates that originate from a hook.

// was changed but the input saw no event or value set

// was copied.

// was part of *our* root.

// was previously checked to update will cause it to be come re-checked

// way it could unblock a transition.

// way this could possibly happen is if this was unmounted, if at all.

// way to define them.

// we *don't* entangle when we should.

// we already scheduled one when we created the queue.

// we are actually fully unblocked it will be fast to replay them.

// we bail out on a parent fiber that then captures an error thrown by

// we can continue to replace it without aborting even if it is not a text

// we can explicitly access globalThis. In older engines we can escape

// we can optimize this reconciliation pass by not tracking side-effects.

// we can remove this, since we track expiration ourselves.

// we can use the eagerly computed state

// we can't use regular timers because they may still be faked

// we could just try to render it client-side instead. However, this will perform a

// we did find already has their listeners attached.

// we do for updates (getCurrentEventPriority).

// we don't know which Flight build this will end up being used

// we don't want them to detect a require and bundle a Node polyfill.

// we haven't gotten to hydrate it yet. There might still be a

// we keep track of which ones already failed during this batch.

// we know that the last error event is the correct one, because it's not

// we may want to special case jsxs internally to take advantage of static children.

// we need to transfer the updates to that queue, too. Because the base

// we need to traverse up through the DOM till we find the correct

// we pass in the meantime. That's going to be our tail in reverse

// we should only put them on the work-in-progress queue, not the current one.

// we should probably never restart.

// we shouldn't set this.

// we want to report this error outside of the normal stack as a last resort.

// we were an insertion and now need to pop up reenter hydration of our

// we will add them all to the child before it gets rendered. That means

// we'd have a different number of entries on the stack depending on

// we'll do a second pass to render the fallback.

// we'll have to schedule a deletion. To do that, this node needs a dummy

// we're bailing out early *without* evaluating the component, we need

// we're currently rendering (which acts like a "thread ID" here).

// we're in a browser

// weak collections should not contains .clear method

// webpackBootstrap

// whatever is currently rendering. So if you call `setState` on a component

// when DevTools forces us to display a fallback; we skip the first render

// when a React.lazy component is a direct child of a

// when multiple updates have the same source, and we only want to respond to

// when the user is inputting text

// when they should be reading from current and writing to workInProgress.

// when we call document.createEvent(). However this can cause confusing

// where the parsing rules cause implicit opens or closes to be added.

// where we should count the work of multiple passes.

// whether getRootHostContext() throws somewhere in renderer code or not.

// whether to retry the primary children, or to skip over it and

// which branch we're currently rendering. Ideally we would model this using

// which cannot be detected. Assuming that it is a US keyboard layout

// which child belongs to which set.

// which flushed updates immediately after the scope function exits, even

// which instance/container to remove the children from.

// which may not match for third party renderers.

// which ones gets to ping. In theory we could get clever and keep

// will be cased anyway with server rendering.

// will be connected to the deleted fiber via its `alternate`:

// will commit it even if something suspended.

// will detect the queue and use it instead of Scheduler.

// will fire for errors that are thrown by destroy functions inside deleted

// will populate textContent as well.

// will sometimes influence the value of checked (even after detachment).

// will still be current since we haven't rendered them yet. The mounted

// window.event assignment in both IE <= 10 as they throw an error

// with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)

// with altered newTarget, not support built-in constructors

// with current event handlers.

// with setTimeout

// with the normal suspend path.

// with the previous one.

// with.

// without calling the reducer again.

// without immediately flushing it. We only do this for user-initiated

// won't dispatch.

// won't update its child set by applying minimal side-effects. Instead,

// work for smaller ids, because you need 5 bits per character.

// work is current during componentDidMount/Update.

// work-in-progress hook.

// worth fixing.

// worth it because we expect very few discrete events to queue up and once

// would during a normal fiber bailout.

// wrap

// wrapper function to constrain it.

// wrong priority associated with it and will prevent hydration of parent path.

// yet (i.e. nothing in the tree has partially rendered) we can

// yet, but we can disconnect the `sibling` and `child` pointers.

// yet. If it is, then it will have a pending insertion effect on it.

// yield* loop.

// you've misconfigured your bundler to force strict mode and applied a

// zero once the queue is empty.

// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.

//# sourceMappingURL=styled-components.browser.esm.js.map
